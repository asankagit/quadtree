/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var _lib_shaderBinder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib/shaderBinder */ \"./src/lib/shaderBinder.js\");\n\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_lib_shaderBinder__WEBPACK_IMPORTED_MODULE_0__.paint);\n\n//# sourceURL=webpack://@asanka-npm/chameleon/./src/index.js?");

/***/ }),

/***/ "./src/lib/shaderBinder.js":
/*!*********************************!*\
  !*** ./src/lib/shaderBinder.js ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   paint: () => (/* binding */ paint)\n/* harmony export */ });\nconst webglUtils  = __webpack_require__(/*! ./webgl-utils */ \"./src/lib/webgl-utils.js\")\n\n\n\n// REFERENCE: https://webglfundamentals.org/webgl/lessons/webgl-3d-textures.html\nfunction render(image, canvasEle, shaderCode=null) {\n    /** @type {HTMLCanvasElement} */\n    var canvas = canvasEle;//document.getElementById(\"glCanvas\");\n    var gl = canvas.getContext(\"webgl\");\n    if (!gl) {\n        return;\n    }\n\n    const vertexShader = shaderCode?.vertex ? shaderCode.vertex : `attribute vec2 a_position;\n    attribute vec2 a_texCoord;\n    \n    uniform vec2 u_resolution;\n    \n    varying vec2 v_texCoord;\n    \n    void main() {\n       // convert the rectangle from pixels to 0.0 to 1.0\n       vec2 zeroToOne = a_position / u_resolution;\n    \n       // convert from 0->1 to 0->2\n       vec2 zeroToTwo = zeroToOne * 2.0;\n    \n       // convert from 0->2 to -1->+1 (clipspace)\n       vec2 clipSpace = zeroToTwo - 1.0;\n    \n       gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n    \n       // pass the texCoord to the fragment shader\n       // The GPU will interpolate this value between points.\n       v_texCoord = a_texCoord;\n    }`;\n\n    const fragmentShader = shaderCode?.fragment ? shaderCode.fragment : `precision mediump float;\n\n    // our texture\n    uniform sampler2D u_image;\n    uniform vec2 iResolution;\n    // the texCoords passed in from the vertex shader.\n    varying vec2 v_texCoord;\n    \n    void main() {\n        vec2 uv = gl_FragCoord.xy / iResolution;\n    \n        // get pixel information from uv location\n        vec4 texColor = texture2D(u_image, v_texCoord).bgra;\n    \n        float intensity = fract(texColor.x * texColor.y * 2.5);\n    \n        //gl_FragColor = texture2D(u_image, v_texCoord).bgra;\n        vec4 color;\n        if (intensity > 0.8)\n            color = vec4(texColor.rgb, 1.0);\n        else if (intensity > 0.5)\n            color = vec4(texColor.rgb, .9);\n        else if (intensity > 0.25)\n            color = vec4(texColor.rgb, .4);\n        else\n            color = vec4(texColor.rgb, .5);\n        \n        float grayScale = (texColor.r + texColor.g + texColor.b) / 3.0;\n        gl_FragColor = vec4(grayScale, texColor.gb * 1.8, 1.0);\n    \n       \n    }`;\n\n    // setup GLSL program\n    var program = webglUtils.createProgramFromScripts(gl,\n        vertexShader, fragmentShader\n        \n    );\n\n    // look up where the vertex data needs to go.\n    var positionLocation = gl.getAttribLocation(program, \"a_position\");\n    var texcoordLocation = gl.getAttribLocation(program, \"a_texCoord\");\n\n    // Create a buffer to put three 2d clip space points in\n    var positionBuffer = gl.createBuffer();\n\n    // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    // Set a rectangle the same size as the image.\n    setRectangle(gl, 0, 0, image.width, image.height);\n\n    // provide texture coordinates for the rectangle.\n    var texcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        0.0, 0.0,\n        1.0, 0.0,\n        0.0, 1.0,\n        0.0, 1.0,\n        1.0, 0.0,\n        1.0, 1.0,\n    ]), gl.STATIC_DRAW);\n\n    // Create a texture.\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    // Set the parameters so we can render any size image.\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n    // Upload the image into the texture.\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n\n    // lookup uniforms\n    var resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\n\n    webglUtils.resizeCanvasToDisplaySize(gl.canvas);\n\n    // Tell WebGL how to convert from clip space to pixels\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    // Clear the canvas\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Tell it to use our program (pair of shaders)\n    gl.useProgram(program);\n\n    // Turn on the position attribute\n    gl.enableVertexAttribArray(positionLocation);\n\n    // Bind the position buffer.\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n    // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)\n    var size = 2;          // 2 components per iteration\n    var type = gl.FLOAT;   // the data is 32bit floats\n    var normalize = false; // don't normalize the data\n    var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position\n    var offset = 0;        // start at the beginning of the buffer\n    gl.vertexAttribPointer(\n        positionLocation, size, type, normalize, stride, offset);\n\n    // Turn on the texcoord attribute\n    gl.enableVertexAttribArray(texcoordLocation);\n\n    // bind the texcoord buffer.\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n\n    // Tell the texcoord attribute how to get data out of texcoordBuffer (ARRAY_BUFFER)\n    var size = 2;          // 2 components per iteration\n    var type = gl.FLOAT;   // the data is 32bit floats\n    var normalize = false; // don't normalize the data\n    var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position\n    var offset = 0;        // start at the beginning of the buffer\n    gl.vertexAttribPointer(\n        texcoordLocation, size, type, normalize, stride, offset);\n\n    // set the resolution\n    gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);\n\n    // Draw the rectangle.\n    var primitiveType = gl.TRIANGLES;\n    var offset = 0;\n    var count = 6;\n    gl.drawArrays(primitiveType, offset, count);\n}\n\nfunction setRectangle(gl, x, y ,width, height) {\n    var x1 = x;\n    var x2 = x + width;\n    var y1 = y;\n    var y2 = y + height;\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        x1, y1,\n        x2, y1,\n        x1, y2,\n        x1, y2,\n        x2, y1,\n        x2, y2,\n    ]), gl.STATIC_DRAW);\n}\n\n\nconst paint = (fileName, canvas, shaderCode=null) => {\n    const image = new Image();\n    image.src = fileName;\n    image.onload = function () {\n        render(image, canvas, shaderCode);\n    };\n}\n\n\n\n\n//# sourceURL=webpack://@asanka-npm/chameleon/./src/lib/shaderBinder.js?");

/***/ }),

/***/ "./src/lib/webgl-utils.js":
/*!********************************!*\
  !*** ./src/lib/webgl-utils.js ***!
  \********************************/
/***/ (function(module, exports) {

eval("var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*\n * Copyright 2021 GFXFundamentals.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of GFXFundamentals. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function(root, factory) {  // eslint-disable-line\n    if (true) {\n      // AMD. Register as an anonymous module.\n      !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n        return factory.call(root);\n      }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    } else {}\n  }(this, function() {\n    'use strict';\n  \n    const topWindow = this;\n  \n    /** @module webgl-utils */\n  \n    function isInIFrame(w) {\n      w = w || topWindow;\n      return w !== w.top;\n    }\n  \n    if (!isInIFrame()) {\n      console.log(\"%c%s\", 'color:blue;font-weight:bold;', 'for more about webgl-utils.js see:');  // eslint-disable-line\n      console.log(\"%c%s\", 'color:blue;font-weight:bold;', 'https://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html');  // eslint-disable-line\n    }\n  \n    /**\n     * Wrapped logging function.\n     * @param {string} msg The message to log.\n     */\n    function error(msg) {\n      if (topWindow.console) {\n        if (topWindow.console.error) {\n          topWindow.console.error(msg);\n        } else if (topWindow.console.log) {\n          topWindow.console.log(msg);\n        }\n      }\n    }\n  \n  \n    /**\n     * Error Callback\n     * @callback ErrorCallback\n     * @param {string} msg error message.\n     * @memberOf module:webgl-utils\n     */\n  \n  \n    /**\n     * Loads a shader.\n     * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n     * @param {string} shaderSource The shader source.\n     * @param {number} shaderType The type of shader.\n     * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.\n     * @return {WebGLShader} The created shader.\n     */\n    function loadShader(gl, shaderSource, shaderType, opt_errorCallback) {\n      const errFn = opt_errorCallback || error;\n      // Create the shader object\n      const shader = gl.createShader(shaderType);\n  \n      // Load the shader source\n      gl.shaderSource(shader, shaderSource);\n  \n      // Compile the shader\n      gl.compileShader(shader);\n  \n      // Check the compile status\n      const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n      if (!compiled) {\n        // Something went wrong during compilation; get the error\n        const lastError = gl.getShaderInfoLog(shader);\n        errFn('*** Error compiling shader \\'' + shader + '\\':' + lastError + `\\n` + shaderSource.split('\\n').map((l,i) => `${i + 1}: ${l}`).join('\\n'));\n        gl.deleteShader(shader);\n        return null;\n      }\n  \n      return shader;\n    }\n  \n    /**\n     * Creates a program, attaches shaders, binds attrib locations, links the\n     * program and calls useProgram.\n     * @param {WebGLShader[]} shaders The shaders to attach\n     * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n     * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n     * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n     *        on error. If you want something else pass an callback. It's passed an error message.\n     * @memberOf module:webgl-utils\n     */\n    function createProgram(\n        gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {\n      const errFn = opt_errorCallback || error;\n      const program = gl.createProgram();\n      shaders.forEach(function(shader) {\n        gl.attachShader(program, shader);\n      });\n      if (opt_attribs) {\n        opt_attribs.forEach(function(attrib, ndx) {\n          gl.bindAttribLocation(\n              program,\n              opt_locations ? opt_locations[ndx] : ndx,\n              attrib);\n        });\n      }\n      gl.linkProgram(program);\n  \n      // Check the link status\n      const linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n      if (!linked) {\n          // something went wrong with the link\n          const lastError = gl.getProgramInfoLog(program);\n          errFn('Error in program linking:' + lastError);\n  \n          gl.deleteProgram(program);\n          return null;\n      }\n      return program;\n    }\n  \n    /**\n     * Loads a shader from a script tag.\n     * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n     * @param {string} scriptId The id of the script tag.\n     * @param {number} opt_shaderType The type of shader. If not passed in it will\n     *     be derived from the type of the script tag.\n     * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.\n     * @return {WebGLShader} The created shader.\n     */\n    function createShaderFromScript(\n        gl, scriptId, opt_shaderType, opt_errorCallback) {\n      let shaderSource = '';\n      let shaderType;\n      const shaderScript = document.getElementById(scriptId);\n      if (!shaderScript) {\n        throw ('*** Error: unknown script element' + scriptId);\n      }\n      shaderSource = shaderScript.text;\n  \n      if (!opt_shaderType) {\n        if (shaderScript.type === 'x-shader/x-vertex') {\n          shaderType = gl.VERTEX_SHADER;\n        } else if (shaderScript.type === 'x-shader/x-fragment') {\n          shaderType = gl.FRAGMENT_SHADER;\n        } else if (shaderType !== gl.VERTEX_SHADER && shaderType !== gl.FRAGMENT_SHADER) {\n          throw ('*** Error: unknown shader type');\n        }\n      }\n  \n      return loadShader(\n          gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType,\n          opt_errorCallback);\n    }\n  \n    const defaultShaderType = [\n      'VERTEX_SHADER',\n      'FRAGMENT_SHADER',\n    ];\n  \n    /**\n     * Creates a program from 2 script tags.\n     *\n     * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n     *        to use.\n     * @param {string[]} shaderScriptIds Array of ids of the script\n     *        tags for the shaders. The first is assumed to be the\n     *        vertex shader, the second the fragment shader.\n     * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n     * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n     * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n     *        on error. If you want something else pass an callback. It's passed an error message.\n     * @return {WebGLProgram} The created program.\n     * @memberOf module:webgl-utils\n     */\n    function createProgramFromScripts_original(\n        gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {\n      const shaders = [];\n      for (let ii = 0; ii < shaderScriptIds.length; ++ii) {\n        shaders.push(createShaderFromScript(\n            gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], opt_errorCallback));\n      }\n      return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);\n    }\n  \n    function createProgramFromScripts(gl, vertexShaderSource, fragmentShaderSource) {\n        // Create vertex shader\n        const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        if (!vertexShader) {\n            console.error('Failed to create vertex shader');\n            return null;\n        }\n        gl.shaderSource(vertexShader, vertexShaderSource);\n        gl.compileShader(vertexShader);\n        // Check for compilation errors...\n    \n        // Create fragment shader\n        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        if (!fragmentShader) {\n            console.error('Failed to create fragment shader');\n            return null;\n        }\n        gl.shaderSource(fragmentShader, fragmentShaderSource);\n        gl.compileShader(fragmentShader);\n        // Check for compilation errors...\n    \n        // Create program\n        const program = gl.createProgram();\n        if (!program) {\n            console.error('Failed to create shader program');\n            return null;\n        }\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        gl.linkProgram(program);\n        // Check for linking errors...\n    \n        return program;\n    }\n    \n    /**\n     * Creates a program from 2 sources.\n     *\n     * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n     *        to use.\n     * @param {string[]} shaderSourcess Array of sources for the\n     *        shaders. The first is assumed to be the vertex shader,\n     *        the second the fragment shader.\n     * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n     * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n     * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n     *        on error. If you want something else pass an callback. It's passed an error message.\n     * @return {WebGLProgram} The created program.\n     * @memberOf module:webgl-utils\n     */\n    function createProgramFromSources(\n        gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n      const shaders = [];\n      for (let ii = 0; ii < shaderSources.length; ++ii) {\n        shaders.push(loadShader(\n            gl, shaderSources[ii], gl[defaultShaderType[ii]], opt_errorCallback));\n      }\n      return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);\n    }\n  \n    /**\n     * Returns the corresponding bind point for a given sampler type\n     */\n    function getBindPointForSamplerType(gl, type) {\n      if (type === gl.SAMPLER_2D)   return gl.TEXTURE_2D;        // eslint-disable-line\n      if (type === gl.SAMPLER_CUBE) return gl.TEXTURE_CUBE_MAP;  // eslint-disable-line\n      return undefined;\n    }\n  \n    /**\n     * @typedef {Object.<string, function>} Setters\n     */\n  \n    /**\n     * Creates setter functions for all uniforms of a shader\n     * program.\n     *\n     * @see {@link module:webgl-utils.setUniforms}\n     *\n     * @param {WebGLProgram} program the program to create setters for.\n     * @returns {Object.<string, function>} an object with a setter by name for each uniform\n     * @memberOf module:webgl-utils\n     */\n    function createUniformSetters(gl, program) {\n      let textureUnit = 0;\n  \n      /**\n       * Creates a setter for a uniform of the given program with it's\n       * location embedded in the setter.\n       * @param {WebGLProgram} program\n       * @param {WebGLUniformInfo} uniformInfo\n       * @returns {function} the created setter.\n       */\n      function createUniformSetter(program, uniformInfo) {\n        const location = gl.getUniformLocation(program, uniformInfo.name);\n        const type = uniformInfo.type;\n        // Check if this uniform is an array\n        const isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === '[0]');\n        if (type === gl.FLOAT && isArray) {\n          return function(v) {\n            gl.uniform1fv(location, v);\n          };\n        }\n        if (type === gl.FLOAT) {\n          return function(v) {\n            gl.uniform1f(location, v);\n          };\n        }\n        if (type === gl.FLOAT_VEC2) {\n          return function(v) {\n            gl.uniform2fv(location, v);\n          };\n        }\n        if (type === gl.FLOAT_VEC3) {\n          return function(v) {\n            gl.uniform3fv(location, v);\n          };\n        }\n        if (type === gl.FLOAT_VEC4) {\n          return function(v) {\n            gl.uniform4fv(location, v);\n          };\n        }\n        if (type === gl.INT && isArray) {\n          return function(v) {\n            gl.uniform1iv(location, v);\n          };\n        }\n        if (type === gl.INT) {\n          return function(v) {\n            gl.uniform1i(location, v);\n          };\n        }\n        if (type === gl.INT_VEC2) {\n          return function(v) {\n            gl.uniform2iv(location, v);\n          };\n        }\n        if (type === gl.INT_VEC3) {\n          return function(v) {\n            gl.uniform3iv(location, v);\n          };\n        }\n        if (type === gl.INT_VEC4) {\n          return function(v) {\n            gl.uniform4iv(location, v);\n          };\n        }\n        if (type === gl.BOOL) {\n          return function(v) {\n            gl.uniform1iv(location, v);\n          };\n        }\n        if (type === gl.BOOL_VEC2) {\n          return function(v) {\n            gl.uniform2iv(location, v);\n          };\n        }\n        if (type === gl.BOOL_VEC3) {\n          return function(v) {\n            gl.uniform3iv(location, v);\n          };\n        }\n        if (type === gl.BOOL_VEC4) {\n          return function(v) {\n            gl.uniform4iv(location, v);\n          };\n        }\n        if (type === gl.FLOAT_MAT2) {\n          return function(v) {\n            gl.uniformMatrix2fv(location, false, v);\n          };\n        }\n        if (type === gl.FLOAT_MAT3) {\n          return function(v) {\n            gl.uniformMatrix3fv(location, false, v);\n          };\n        }\n        if (type === gl.FLOAT_MAT4) {\n          return function(v) {\n            gl.uniformMatrix4fv(location, false, v);\n          };\n        }\n        if ((type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) && isArray) {\n          const units = [];\n          for (let ii = 0; ii < info.size; ++ii) {\n            units.push(textureUnit++);\n          }\n          return function(bindPoint, units) {\n            return function(textures) {\n              gl.uniform1iv(location, units);\n              textures.forEach(function(texture, index) {\n                gl.activeTexture(gl.TEXTURE0 + units[index]);\n                gl.bindTexture(bindPoint, texture);\n              });\n            };\n          }(getBindPointForSamplerType(gl, type), units);\n        }\n        if (type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) {\n          return function(bindPoint, unit) {\n            return function(texture) {\n              gl.uniform1i(location, unit);\n              gl.activeTexture(gl.TEXTURE0 + unit);\n              gl.bindTexture(bindPoint, texture);\n            };\n          }(getBindPointForSamplerType(gl, type), textureUnit++);\n        }\n        throw ('unknown type: 0x' + type.toString(16)); // we should never get here.\n      }\n  \n      const uniformSetters = { };\n      const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n  \n      for (let ii = 0; ii < numUniforms; ++ii) {\n        const uniformInfo = gl.getActiveUniform(program, ii);\n        if (!uniformInfo) {\n          break;\n        }\n        let name = uniformInfo.name;\n        // remove the array suffix.\n        if (name.substr(-3) === '[0]') {\n          name = name.substr(0, name.length - 3);\n        }\n        const setter = createUniformSetter(program, uniformInfo);\n        uniformSetters[name] = setter;\n      }\n      return uniformSetters;\n    }\n  \n    /**\n     * Set uniforms and binds related textures.\n     *\n     * Example:\n     *\n     *     let programInfo = createProgramInfo(\n     *         gl, [\"some-vs\", \"some-fs\"]);\n     *\n     *     let tex1 = gl.createTexture();\n     *     let tex2 = gl.createTexture();\n     *\n     *     ... assume we setup the textures with data ...\n     *\n     *     let uniforms = {\n     *       u_someSampler: tex1,\n     *       u_someOtherSampler: tex2,\n     *       u_someColor: [1,0,0,1],\n     *       u_somePosition: [0,1,1],\n     *       u_someMatrix: [\n     *         1,0,0,0,\n     *         0,1,0,0,\n     *         0,0,1,0,\n     *         0,0,0,0,\n     *       ],\n     *     };\n     *\n     *     gl.useProgram(program);\n     *\n     * This will automatically bind the textures AND set the\n     * uniforms.\n     *\n     *     setUniforms(programInfo.uniformSetters, uniforms);\n     *\n     * For the example above it is equivalent to\n     *\n     *     let texUnit = 0;\n     *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n     *     gl.bindTexture(gl.TEXTURE_2D, tex1);\n     *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n     *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n     *     gl.bindTexture(gl.TEXTURE_2D, tex2);\n     *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n     *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);\n     *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);\n     *     gl.uniformMatrix4fv(u_someMatrix, false, [\n     *         1,0,0,0,\n     *         0,1,0,0,\n     *         0,0,1,0,\n     *         0,0,0,0,\n     *       ]);\n     *\n     * Note it is perfectly reasonable to call `setUniforms` multiple times. For example\n     *\n     *     let uniforms = {\n     *       u_someSampler: tex1,\n     *       u_someOtherSampler: tex2,\n     *     };\n     *\n     *     let moreUniforms {\n     *       u_someColor: [1,0,0,1],\n     *       u_somePosition: [0,1,1],\n     *       u_someMatrix: [\n     *         1,0,0,0,\n     *         0,1,0,0,\n     *         0,0,1,0,\n     *         0,0,0,0,\n     *       ],\n     *     };\n     *\n     *     setUniforms(programInfo.uniformSetters, uniforms);\n     *     setUniforms(programInfo.uniformSetters, moreUniforms);\n     *\n     * @param {Object.<string, function>|module:webgl-utils.ProgramInfo} setters the setters returned from\n     *        `createUniformSetters` or a ProgramInfo from {@link module:webgl-utils.createProgramInfo}.\n     * @param {Object.<string, value>} an object with values for the\n     *        uniforms.\n     * @memberOf module:webgl-utils\n     */\n    function setUniforms(setters, ...values) {\n      setters = setters.uniformSetters || setters;\n      for (const uniforms of values) {\n        Object.keys(uniforms).forEach(function(name) {\n          const setter = setters[name];\n          if (setter) {\n            setter(uniforms[name]);\n          }\n        });\n      }\n    }\n  \n    /**\n     * Creates setter functions for all attributes of a shader\n     * program. You can pass this to {@link module:webgl-utils.setBuffersAndAttributes} to set all your buffers and attributes.\n     *\n     * @see {@link module:webgl-utils.setAttributes} for example\n     * @param {WebGLProgram} program the program to create setters for.\n     * @return {Object.<string, function>} an object with a setter for each attribute by name.\n     * @memberOf module:webgl-utils\n     */\n    function createAttributeSetters(gl, program) {\n      const attribSetters = {\n      };\n  \n      function createAttribSetter(index) {\n        return function(b) {\n            if (b.value) {\n              gl.disableVertexAttribArray(index);\n              switch (b.value.length) {\n                case 4:\n                  gl.vertexAttrib4fv(index, b.value);\n                  break;\n                case 3:\n                  gl.vertexAttrib3fv(index, b.value);\n                  break;\n                case 2:\n                  gl.vertexAttrib2fv(index, b.value);\n                  break;\n                case 1:\n                  gl.vertexAttrib1fv(index, b.value);\n                  break;\n                default:\n                  throw new Error('the length of a float constant value must be between 1 and 4!');\n              }\n            } else {\n              gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n              gl.enableVertexAttribArray(index);\n              gl.vertexAttribPointer(\n                  index, b.numComponents || b.size, b.type || gl.FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);\n            }\n          };\n      }\n  \n      const numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n      for (let ii = 0; ii < numAttribs; ++ii) {\n        const attribInfo = gl.getActiveAttrib(program, ii);\n        if (!attribInfo) {\n          break;\n        }\n        const index = gl.getAttribLocation(program, attribInfo.name);\n        attribSetters[attribInfo.name] = createAttribSetter(index);\n      }\n  \n      return attribSetters;\n    }\n  \n    /**\n     * Sets attributes and binds buffers (deprecated... use {@link module:webgl-utils.setBuffersAndAttributes})\n     *\n     * Example:\n     *\n     *     let program = createProgramFromScripts(\n     *         gl, [\"some-vs\", \"some-fs\"]);\n     *\n     *     let attribSetters = createAttributeSetters(program);\n     *\n     *     let positionBuffer = gl.createBuffer();\n     *     let texcoordBuffer = gl.createBuffer();\n     *\n     *     let attribs = {\n     *       a_position: {buffer: positionBuffer, numComponents: 3},\n     *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n     *     };\n     *\n     *     gl.useProgram(program);\n     *\n     * This will automatically bind the buffers AND set the\n     * attributes.\n     *\n     *     setAttributes(attribSetters, attribs);\n     *\n     * Properties of attribs. For each attrib you can add\n     * properties:\n     *\n     * *   type: the type of data in the buffer. Default = gl.FLOAT\n     * *   normalize: whether or not to normalize the data. Default = false\n     * *   stride: the stride. Default = 0\n     * *   offset: offset into the buffer. Default = 0\n     *\n     * For example if you had 3 value float positions, 2 value\n     * float texcoord and 4 value uint8 colors you'd setup your\n     * attribs like this\n     *\n     *     let attribs = {\n     *       a_position: {buffer: positionBuffer, numComponents: 3},\n     *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n     *       a_color: {\n     *         buffer: colorBuffer,\n     *         numComponents: 4,\n     *         type: gl.UNSIGNED_BYTE,\n     *         normalize: true,\n     *       },\n     *     };\n     *\n     * @param {Object.<string, function>|model:webgl-utils.ProgramInfo} setters Attribute setters as returned from createAttributeSetters or a ProgramInfo as returned {@link module:webgl-utils.createProgramInfo}\n     * @param {Object.<string, module:webgl-utils.AttribInfo>} attribs AttribInfos mapped by attribute name.\n     * @memberOf module:webgl-utils\n     * @deprecated use {@link module:webgl-utils.setBuffersAndAttributes}\n     */\n    function setAttributes(setters, attribs) {\n      setters = setters.attribSetters || setters;\n      Object.keys(attribs).forEach(function(name) {\n        const setter = setters[name];\n        if (setter) {\n          setter(attribs[name]);\n        }\n      });\n    }\n  \n    /**\n     * Creates a vertex array object and then sets the attributes\n     * on it\n     *\n     * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n     *        to use.\n     * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters\n     * @param {Object.<string, module:webgl-utils.AttribInfo>} attribs AttribInfos mapped by attribute name.\n     * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices\n     */\n    function createVAOAndSetAttributes(gl, setters, attribs, indices) {\n      const vao = gl.createVertexArray();\n      gl.bindVertexArray(vao);\n      setAttributes(setters, attribs);\n      if (indices) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n      }\n      // We unbind this because otherwise any change to ELEMENT_ARRAY_BUFFER\n      // like when creating buffers for other stuff will mess up this VAO's binding\n      gl.bindVertexArray(null);\n      return vao;\n    }\n  \n    /**\n     * Creates a vertex array object and then sets the attributes\n     * on it\n     *\n     * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n     *        to use.\n     * @param {Object.<string, function>| module:webgl-utils.ProgramInfo} programInfo as returned from createProgramInfo or Attribute setters as returned from createAttributeSetters\n     * @param {module:webgl-utils:BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...\n     * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices\n     */\n    function createVAOFromBufferInfo(gl, programInfo, bufferInfo) {\n      return createVAOAndSetAttributes(gl, programInfo.attribSetters || programInfo, bufferInfo.attribs, bufferInfo.indices);\n    }\n  \n    /**\n     * @typedef {Object} ProgramInfo\n     * @property {WebGLProgram} program A shader program\n     * @property {Object<string, function>} uniformSetters: object of setters as returned from createUniformSetters,\n     * @property {Object<string, function>} attribSetters: object of setters as returned from createAttribSetters,\n     * @memberOf module:webgl-utils\n     */\n  \n    /**\n     * Creates a ProgramInfo from 2 sources.\n     *\n     * A ProgramInfo contains\n     *\n     *     programInfo = {\n     *        program: WebGLProgram,\n     *        uniformSetters: object of setters as returned from createUniformSetters,\n     *        attribSetters: object of setters as returned from createAttribSetters,\n     *     }\n     *\n     * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n     *        to use.\n     * @param {string[]} shaderSourcess Array of sources for the\n     *        shaders or ids. The first is assumed to be the vertex shader,\n     *        the second the fragment shader.\n     * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n     * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n     * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n     *        on error. If you want something else pass an callback. It's passed an error message.\n     * @return {module:webgl-utils.ProgramInfo} The created program.\n     * @memberOf module:webgl-utils\n     */\n    function createProgramInfo(\n        gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n      shaderSources = shaderSources.map(function(source) {\n        const script = document.getElementById(source);\n        return script ? script.text : source;\n      });\n      const program = webglUtils.createProgramFromSources(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback);\n      if (!program) {\n        return null;\n      }\n      const uniformSetters = createUniformSetters(gl, program);\n      const attribSetters = createAttributeSetters(gl, program);\n      return {\n        program: program,\n        uniformSetters: uniformSetters,\n        attribSetters: attribSetters,\n      };\n    }\n  \n    /**\n     * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate\n     *\n     * Example:\n     *\n     *     let programInfo = createProgramInfo(\n     *         gl, [\"some-vs\", \"some-fs\"]);\n     *\n     *     let arrays = {\n     *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n     *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n     *     };\n     *\n     *     let bufferInfo = createBufferInfoFromArrays(gl, arrays);\n     *\n     *     gl.useProgram(programInfo.program);\n     *\n     * This will automatically bind the buffers AND set the\n     * attributes.\n     *\n     *     setBuffersAndAttributes(programInfo.attribSetters, bufferInfo);\n     *\n     * For the example above it is equivilent to\n     *\n     *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n     *     gl.enableVertexAttribArray(a_positionLocation);\n     *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);\n     *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n     *     gl.enableVertexAttribArray(a_texcoordLocation);\n     *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);\n     *\n     * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n     * @param {Object.<string, function>} setters Attribute setters as returned from `createAttributeSetters`\n     * @param {module:webgl-utils.BufferInfo} buffers a BufferInfo as returned from `createBufferInfoFromArrays`.\n     * @memberOf module:webgl-utils\n     */\n    function setBuffersAndAttributes(gl, setters, buffers) {\n      setAttributes(setters, buffers.attribs);\n      if (buffers.indices) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\n      }\n    }\n  \n    // Add your prefix here.\n    const browserPrefixes = [\n      '',\n      'MOZ_',\n      'OP_',\n      'WEBKIT_',\n    ];\n  \n    /**\n     * Given an extension name like WEBGL_compressed_texture_s3tc\n     * returns the supported version extension, like\n     * WEBKIT_WEBGL_compressed_teture_s3tc\n     * @param {string} name Name of extension to look for\n     * @return {WebGLExtension} The extension or undefined if not\n     *     found.\n     * @memberOf module:webgl-utils\n     */\n    function getExtensionWithKnownPrefixes(gl, name) {\n      for (let ii = 0; ii < browserPrefixes.length; ++ii) {\n        const prefixedName = browserPrefixes[ii] + name;\n        const ext = gl.getExtension(prefixedName);\n        if (ext) {\n          return ext;\n        }\n      }\n      return undefined;\n    }\n  \n    /**\n     * Resize a canvas to match the size its displayed.\n     * @param {HTMLCanvasElement} canvas The canvas to resize.\n     * @param {number} [multiplier] amount to multiply by.\n     *    Pass in window.devicePixelRatio for native pixels.\n     * @return {boolean} true if the canvas was resized.\n     * @memberOf module:webgl-utils\n     */\n    function resizeCanvasToDisplaySize(canvas, multiplier) {\n      multiplier = multiplier || 1;\n      const width  = canvas.clientWidth  * multiplier | 0;\n      const height = canvas.clientHeight * multiplier | 0;\n      if (canvas.width !== width ||  canvas.height !== height) {\n        canvas.width  = width;\n        canvas.height = height;\n        return true;\n      }\n      return false;\n    }\n  \n    // Add `push` to a typed array. It just keeps a 'cursor'\n    // and allows use to `push` values into the array so we\n    // don't have to manually compute offsets\n    function augmentTypedArray(typedArray, numComponents) {\n      let cursor = 0;\n      typedArray.push = function() {\n        for (let ii = 0; ii < arguments.length; ++ii) {\n          const value = arguments[ii];\n          if (value instanceof Array || (value.buffer && value.buffer instanceof ArrayBuffer)) {\n            for (let jj = 0; jj < value.length; ++jj) {\n              typedArray[cursor++] = value[jj];\n            }\n          } else {\n            typedArray[cursor++] = value;\n          }\n        }\n      };\n      typedArray.reset = function(opt_index) {\n        cursor = opt_index || 0;\n      };\n      typedArray.numComponents = numComponents;\n      Object.defineProperty(typedArray, 'numElements', {\n        get: function() {\n          return this.length / this.numComponents | 0;\n        },\n      });\n      return typedArray;\n    }\n  \n    /**\n     * creates a typed array with a `push` function attached\n     * so that you can easily *push* values.\n     *\n     * `push` can take multiple arguments. If an argument is an array each element\n     * of the array will be added to the typed array.\n     *\n     * Example:\n     *\n     *     let array = createAugmentedTypedArray(3, 2);  // creates a Float32Array with 6 values\n     *     array.push(1, 2, 3);\n     *     array.push([4, 5, 6]);\n     *     // array now contains [1, 2, 3, 4, 5, 6]\n     *\n     * Also has `numComponents` and `numElements` properties.\n     *\n     * @param {number} numComponents number of components\n     * @param {number} numElements number of elements. The total size of the array will be `numComponents * numElements`.\n     * @param {constructor} opt_type A constructor for the type. Default = `Float32Array`.\n     * @return {ArrayBuffer} A typed array.\n     * @memberOf module:webgl-utils\n     */\n    function createAugmentedTypedArray(numComponents, numElements, opt_type) {\n      const Type = opt_type || Float32Array;\n      return augmentTypedArray(new Type(numComponents * numElements), numComponents);\n    }\n  \n    function createBufferFromTypedArray(gl, array, type, drawType) {\n      type = type || gl.ARRAY_BUFFER;\n      const buffer = gl.createBuffer();\n      gl.bindBuffer(type, buffer);\n      gl.bufferData(type, array, drawType || gl.STATIC_DRAW);\n      return buffer;\n    }\n  \n    function allButIndices(name) {\n      return name !== 'indices';\n    }\n  \n    function createMapping(obj) {\n      const mapping = {};\n      Object.keys(obj).filter(allButIndices).forEach(function(key) {\n        mapping['a_' + key] = key;\n      });\n      return mapping;\n    }\n  \n    function getGLTypeForTypedArray(gl, typedArray) {\n      if (typedArray instanceof Int8Array)    { return gl.BYTE; }            // eslint-disable-line\n      if (typedArray instanceof Uint8Array)   { return gl.UNSIGNED_BYTE; }   // eslint-disable-line\n      if (typedArray instanceof Int16Array)   { return gl.SHORT; }           // eslint-disable-line\n      if (typedArray instanceof Uint16Array)  { return gl.UNSIGNED_SHORT; }  // eslint-disable-line\n      if (typedArray instanceof Int32Array)   { return gl.INT; }             // eslint-disable-line\n      if (typedArray instanceof Uint32Array)  { return gl.UNSIGNED_INT; }    // eslint-disable-line\n      if (typedArray instanceof Float32Array) { return gl.FLOAT; }           // eslint-disable-line\n      throw 'unsupported typed array type';\n    }\n  \n    // This is really just a guess. Though I can't really imagine using\n    // anything else? Maybe for some compression?\n    function getNormalizationForTypedArray(typedArray) {\n      if (typedArray instanceof Int8Array)    { return true; }  // eslint-disable-line\n      if (typedArray instanceof Uint8Array)   { return true; }  // eslint-disable-line\n      return false;\n    }\n  \n    function isArrayBuffer(a) {\n      return a.buffer && a.buffer instanceof ArrayBuffer;\n    }\n  \n    function guessNumComponentsFromName(name, length) {\n      let numComponents;\n      if (name.indexOf('coord') >= 0) {\n        numComponents = 2;\n      } else if (name.indexOf('color') >= 0) {\n        numComponents = 4;\n      } else {\n        numComponents = 3;  // position, normals, indices ...\n      }\n  \n      if (length % numComponents > 0) {\n        throw 'can not guess numComponents. You should specify it.';\n      }\n  \n      return numComponents;\n    }\n  \n    function makeTypedArray(array, name) {\n      if (isArrayBuffer(array)) {\n        return array;\n      }\n  \n      if (array.data && isArrayBuffer(array.data)) {\n        return array.data;\n      }\n  \n      if (Array.isArray(array)) {\n        array = {\n          data: array,\n        };\n      }\n  \n      if (!array.numComponents) {\n        array.numComponents = guessNumComponentsFromName(name, array.length);\n      }\n  \n      let type = array.type;\n      if (!type) {\n        if (name === 'indices') {\n          type = Uint16Array;\n        }\n      }\n      const typedArray = createAugmentedTypedArray(array.numComponents, array.data.length / array.numComponents | 0, type);\n      typedArray.push(array.data);\n      return typedArray;\n    }\n  \n    /**\n     * @typedef {Object} AttribInfo\n     * @property {number} [numComponents] the number of components for this attribute.\n     * @property {number} [size] the number of components for this attribute.\n     * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`\n     * @property {boolean} [normalized] whether or not to normalize the data. Default = false\n     * @property {number} [offset] offset into buffer in bytes. Default = 0\n     * @property {number} [stride] the stride in bytes per element. Default = 0\n     * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute\n     * @memberOf module:webgl-utils\n     */\n  \n  \n    /**\n     * Creates a set of attribute data and WebGLBuffers from set of arrays\n     *\n     * Given\n     *\n     *      let arrays = {\n     *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n     *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n     *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n     *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },\n     *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n     *      };\n     *\n     * returns something like\n     *\n     *      let attribs = {\n     *        a_position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n     *        a_texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n     *        a_normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n     *        a_color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },\n     *      };\n     *\n     * @param {WebGLRenderingContext} gl The webgl rendering context.\n     * @param {Object.<string, array|typedarray>} arrays The arrays\n     * @param {Object.<string, string>} [opt_mapping] mapping from attribute name to array name.\n     *     if not specified defaults to \"a_name\" -> \"name\".\n     * @return {Object.<string, module:webgl-utils.AttribInfo>} the attribs\n     * @memberOf module:webgl-utils\n     */\n    function createAttribsFromArrays(gl, arrays, opt_mapping) {\n      const mapping = opt_mapping || createMapping(arrays);\n      const attribs = {};\n      Object.keys(mapping).forEach(function(attribName) {\n        const bufferName = mapping[attribName];\n        const origArray = arrays[bufferName];\n        if (origArray.value) {\n          attribs[attribName] = {\n            value: origArray.value,\n          };\n        } else {\n          const array = makeTypedArray(origArray, bufferName);\n          attribs[attribName] = {\n            buffer:        createBufferFromTypedArray(gl, array),\n            numComponents: origArray.numComponents || array.numComponents || guessNumComponentsFromName(bufferName),\n            type:          getGLTypeForTypedArray(gl, array),\n            normalize:     getNormalizationForTypedArray(array),\n          };\n        }\n      });\n      return attribs;\n    }\n  \n    function getArray(array) {\n      return array.length ? array : array.data;\n    }\n  \n    const texcoordRE = /coord|texture/i;\n    const colorRE = /color|colour/i;\n  \n    function guessNumComponentsFromName(name, length) {\n      let numComponents;\n      if (texcoordRE.test(name)) {\n        numComponents = 2;\n      } else if (colorRE.test(name)) {\n        numComponents = 4;\n      } else {\n        numComponents = 3;  // position, normals, indices ...\n      }\n  \n      if (length % numComponents > 0) {\n        throw new Error(`Can not guess numComponents for attribute '${name}'. Tried ${numComponents} but ${length} values is not evenly divisible by ${numComponents}. You should specify it.`);\n      }\n  \n      return numComponents;\n    }\n  \n    function getNumComponents(array, arrayName) {\n      return array.numComponents || array.size || guessNumComponentsFromName(arrayName, getArray(array).length);\n    }\n  \n    /**\n     * tries to get the number of elements from a set of arrays.\n     */\n    const positionKeys = ['position', 'positions', 'a_position'];\n    function getNumElementsFromNonIndexedArrays(arrays) {\n      let key;\n      for (const k of positionKeys) {\n        if (k in arrays) {\n          key = k;\n          break;\n        }\n      }\n      key = key || Object.keys(arrays)[0];\n      const array = arrays[key];\n      const length = getArray(array).length;\n      const numComponents = getNumComponents(array, key);\n      const numElements = length / numComponents;\n      if (length % numComponents > 0) {\n        throw new Error(`numComponents ${numComponents} not correct for length ${length}`);\n      }\n      return numElements;\n    }\n  \n    /**\n     * @typedef {Object} BufferInfo\n     * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.\n     * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.\n     * @property {Object.<string, module:webgl-utils.AttribInfo>} attribs The attribs approriate to call `setAttributes`\n     * @memberOf module:webgl-utils\n     */\n  \n  \n    /**\n     * Creates a BufferInfo from an object of arrays.\n     *\n     * This can be passed to {@link module:webgl-utils.setBuffersAndAttributes} and to\n     * {@link module:webgl-utils:drawBufferInfo}.\n     *\n     * Given an object like\n     *\n     *     let arrays = {\n     *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n     *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n     *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n     *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n     *     };\n     *\n     *  Creates an BufferInfo like this\n     *\n     *     bufferInfo = {\n     *       numElements: 4,        // or whatever the number of elements is\n     *       indices: WebGLBuffer,  // this property will not exist if there are no indices\n     *       attribs: {\n     *         a_position: { buffer: WebGLBuffer, numComponents: 3, },\n     *         a_normal:   { buffer: WebGLBuffer, numComponents: 3, },\n     *         a_texcoord: { buffer: WebGLBuffer, numComponents: 2, },\n     *       },\n     *     };\n     *\n     *  The properties of arrays can be JavaScript arrays in which case the number of components\n     *  will be guessed.\n     *\n     *     let arrays = {\n     *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],\n     *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],\n     *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],\n     *        indices:  [0, 1, 2, 1, 2, 3],\n     *     };\n     *\n     *  They can also by TypedArrays\n     *\n     *     let arrays = {\n     *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),\n     *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),\n     *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),\n     *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),\n     *     };\n     *\n     *  Or augmentedTypedArrays\n     *\n     *     let positions = createAugmentedTypedArray(3, 4);\n     *     let texcoords = createAugmentedTypedArray(2, 4);\n     *     let normals   = createAugmentedTypedArray(3, 4);\n     *     let indices   = createAugmentedTypedArray(3, 2, Uint16Array);\n     *\n     *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);\n     *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);\n     *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);\n     *     indices.push([0, 1, 2, 1, 2, 3]);\n     *\n     *     let arrays = {\n     *        position: positions,\n     *        texcoord: texcoords,\n     *        normal:   normals,\n     *        indices:  indices,\n     *     };\n     *\n     * For the last example it is equivalent to\n     *\n     *     let bufferInfo = {\n     *       attribs: {\n     *         a_position: { numComponents: 3, buffer: gl.createBuffer(), },\n     *         a_texcoods: { numComponents: 2, buffer: gl.createBuffer(), },\n     *         a_normals: { numComponents: 3, buffer: gl.createBuffer(), },\n     *       },\n     *       indices: gl.createBuffer(),\n     *       numElements: 6,\n     *     };\n     *\n     *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_position.buffer);\n     *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);\n     *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_texcoord.buffer);\n     *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);\n     *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_normal.buffer);\n     *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);\n     *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);\n     *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);\n     *\n     * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n     * @param {Object.<string, array|object|typedarray>} arrays Your data\n     * @param {Object.<string, string>} [opt_mapping] an optional mapping of attribute to array name.\n     *    If not passed in it's assumed the array names will be mapped to an attribute\n     *    of the same name with \"a_\" prefixed to it. An other words.\n     *\n     *        let arrays = {\n     *           position: ...,\n     *           texcoord: ...,\n     *           normal:   ...,\n     *           indices:  ...,\n     *        };\n     *\n     *        bufferInfo = createBufferInfoFromArrays(gl, arrays);\n     *\n     *    Is the same as\n     *\n     *        let arrays = {\n     *           position: ...,\n     *           texcoord: ...,\n     *           normal:   ...,\n     *           indices:  ...,\n     *        };\n     *\n     *        let mapping = {\n     *          a_position: \"position\",\n     *          a_texcoord: \"texcoord\",\n     *          a_normal:   \"normal\",\n     *        };\n     *\n     *        bufferInfo = createBufferInfoFromArrays(gl, arrays, mapping);\n     *\n     * @return {module:webgl-utils.BufferInfo} A BufferInfo\n     * @memberOf module:webgl-utils\n     */\n    function createBufferInfoFromArrays(gl, arrays, opt_mapping) {\n      const bufferInfo = {\n        attribs: createAttribsFromArrays(gl, arrays, opt_mapping),\n      };\n      let indices = arrays.indices;\n      if (indices) {\n        indices = makeTypedArray(indices, 'indices');\n        bufferInfo.indices = createBufferFromTypedArray(gl, indices, gl.ELEMENT_ARRAY_BUFFER);\n        bufferInfo.numElements = indices.length;\n      } else {\n        bufferInfo.numElements = getNumElementsFromNonIndexedArrays(arrays);\n      }\n  \n      return bufferInfo;\n    }\n  \n    /**\n     * Creates buffers from typed arrays\n     *\n     * Given something like this\n     *\n     *     let arrays = {\n     *        positions: [1, 2, 3],\n     *        normals: [0, 0, 1],\n     *     }\n     *\n     * returns something like\n     *\n     *     buffers = {\n     *       positions: WebGLBuffer,\n     *       normals: WebGLBuffer,\n     *     }\n     *\n     * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.\n     *\n     * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n     * @param {Object<string, array|typedarray>} arrays\n     * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array\n     * @memberOf module:webgl-utils\n     */\n    function createBuffersFromArrays(gl, arrays) {\n      const buffers = { };\n      Object.keys(arrays).forEach(function(key) {\n        const type = key === 'indices' ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n        const array = makeTypedArray(arrays[key], name);\n        buffers[key] = createBufferFromTypedArray(gl, array, type);\n      });\n  \n      // hrm\n      if (arrays.indices) {\n        buffers.numElements = arrays.indices.length;\n      } else if (arrays.position) {\n        buffers.numElements = arrays.position.length / 3;\n      }\n  \n      return buffers;\n    }\n  \n    /**\n     * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate\n     *\n     * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself\n     * but calling this means if you switch from indexed data to non-indexed\n     * data you don't have to remember to update your draw call.\n     *\n     * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n     * @param {module:webgl-utils.BufferInfo} bufferInfo as returned from createBufferInfoFromArrays\n     * @param {enum} [primitiveType] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...)\n     * @param {number} [count] An optional count. Defaults to bufferInfo.numElements\n     * @param {number} [offset] An optional offset. Defaults to 0.\n     * @memberOf module:webgl-utils\n     */\n    function drawBufferInfo(gl, bufferInfo, primitiveType, count, offset) {\n      const indices = bufferInfo.indices;\n      primitiveType = primitiveType === undefined ? gl.TRIANGLES : primitiveType;\n      const numElements = count === undefined ? bufferInfo.numElements : count;\n      offset = offset === undefined ? 0 : offset;\n      if (indices) {\n        gl.drawElements(primitiveType, numElements, gl.UNSIGNED_SHORT, offset);\n      } else {\n        gl.drawArrays(primitiveType, offset, numElements);\n      }\n    }\n  \n    /**\n     * @typedef {Object} DrawObject\n     * @property {module:webgl-utils.ProgramInfo} programInfo A ProgramInfo as returned from createProgramInfo\n     * @property {module:webgl-utils.BufferInfo} bufferInfo A BufferInfo as returned from createBufferInfoFromArrays\n     * @property {Object<string, ?>} uniforms The values for the uniforms\n     * @memberOf module:webgl-utils\n     */\n  \n    /**\n     * Draws a list of objects\n     * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n     * @param {DrawObject[]} objectsToDraw an array of objects to draw.\n     * @memberOf module:webgl-utils\n     */\n    function drawObjectList(gl, objectsToDraw) {\n      let lastUsedProgramInfo = null;\n      let lastUsedBufferInfo = null;\n  \n      objectsToDraw.forEach(function(object) {\n        const programInfo = object.programInfo;\n        const bufferInfo = object.bufferInfo;\n        let bindBuffers = false;\n  \n        if (programInfo !== lastUsedProgramInfo) {\n          lastUsedProgramInfo = programInfo;\n          gl.useProgram(programInfo.program);\n          bindBuffers = true;\n        }\n  \n        // Setup all the needed attributes.\n        if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {\n          lastUsedBufferInfo = bufferInfo;\n          setBuffersAndAttributes(gl, programInfo.attribSetters, bufferInfo);\n        }\n  \n        // Set the uniforms.\n        setUniforms(programInfo.uniformSetters, object.uniforms);\n  \n        // Draw\n        drawBufferInfo(gl, bufferInfo);\n      });\n    }\n  \n    function glEnumToString(gl, v) {\n      const results = [];\n      for (const key in gl) {\n        if (gl[key] === v) {\n          results.push(key);\n        }\n      }\n      return results.length\n          ? results.join(' | ')\n          : `0x${v.toString(16)}`;\n    }\n  \n    const isIE = /*@cc_on!@*/ false || !!document.documentMode;\n    // Edge 20+\n    const isEdge = !isIE && !!window.StyleMedia;\n    if (isEdge) {\n      // Hack for Edge. Edge's WebGL implmentation is crap still and so they\n      // only respond to \"experimental-webgl\". I don't want to clutter the\n      // examples with that so his hack works around it\n      HTMLCanvasElement.prototype.getContext = function(origFn) {\n        return function() {\n          let args = arguments;\n          const type = args[0];\n          if (type === 'webgl') {\n            args = [].slice.call(arguments);\n            args[0] = 'experimental-webgl';\n          }\n          return origFn.apply(this, args);\n        };\n      }(HTMLCanvasElement.prototype.getContext);\n    }\n  \n    return {\n      createAugmentedTypedArray: createAugmentedTypedArray,\n      createAttribsFromArrays: createAttribsFromArrays,\n      createBuffersFromArrays: createBuffersFromArrays,\n      createBufferInfoFromArrays: createBufferInfoFromArrays,\n      createAttributeSetters: createAttributeSetters,\n      createProgram: createProgram,\n      createProgramFromScripts: createProgramFromScripts,\n      createProgramFromSources: createProgramFromSources,\n      createProgramInfo: createProgramInfo,\n      createUniformSetters: createUniformSetters,\n      createVAOAndSetAttributes: createVAOAndSetAttributes,\n      createVAOFromBufferInfo: createVAOFromBufferInfo,\n      drawBufferInfo: drawBufferInfo,\n      drawObjectList: drawObjectList,\n      glEnumToString: glEnumToString,\n      getExtensionWithKnownPrefixes: getExtensionWithKnownPrefixes,\n      resizeCanvasToDisplaySize: resizeCanvasToDisplaySize,\n      setAttributes: setAttributes,\n      setBuffersAndAttributes: setBuffersAndAttributes,\n      setUniforms: setUniforms,\n    };\n  \n  }));\n\n//# sourceURL=webpack://@asanka-npm/chameleon/./src/lib/webgl-utils.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	var __webpack_export_target__ = exports;
/******/ 	for(var i in __webpack_exports__) __webpack_export_target__[i] = __webpack_exports__[i];
/******/ 	if(__webpack_exports__.__esModule) Object.defineProperty(__webpack_export_target__, "__esModule", { value: true });
/******/ 	
/******/ })()
;