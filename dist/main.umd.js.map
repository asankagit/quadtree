{"version":3,"file":"main.umd.js","mappings":"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","sources":["webpack://@asanka-npm/chameleon/webpack/universalModuleDefinition","webpack://@asanka-npm/chameleon/./src/lib/webgl-utils.js","webpack://@asanka-npm/chameleon/webpack/bootstrap","webpack://@asanka-npm/chameleon/webpack/runtime/define property getters","webpack://@asanka-npm/chameleon/webpack/runtime/hasOwnProperty shorthand","webpack://@asanka-npm/chameleon/webpack/runtime/make namespace object","webpack://@asanka-npm/chameleon/./src/lib/shaderBinder.js","webpack://@asanka-npm/chameleon/./src/shaders/flat-gray.js","webpack://@asanka-npm/chameleon/./src/shaders/graScale.js","webpack://@asanka-npm/chameleon/./src/index.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"@asanka-npm/chameleon\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"@asanka-npm/chameleon\"] = factory();\n\telse\n\t\troot[\"@asanka-npm/chameleon\"] = factory();\n})(this, () => {\nreturn ","/*\n * Copyright 2021 GFXFundamentals.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n *     * Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *     * Redistributions in binary form must reproduce the above\n * copyright notice, this list of conditions and the following disclaimer\n * in the documentation and/or other materials provided with the\n * distribution.\n *     * Neither the name of GFXFundamentals. nor the names of his\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function(root, factory) {  // eslint-disable-line\n    if (typeof define === 'function' && define.amd) {\n      // AMD. Register as an anonymous module.\n      define([], function() {\n        return factory.call(root);\n      });\n    } else {\n      // Browser globals\n      root.webglUtils = factory.call(root);\n    }\n  }(this, function() {\n    'use strict';\n  \n    const topWindow = this;\n  \n    /** @module webgl-utils */\n  \n    function isInIFrame(w) {\n      w = w || topWindow;\n      return w !== w.top;\n    }\n  \n    if (!isInIFrame()) {\n      console.log(\"%c%s\", 'color:blue;font-weight:bold;', 'for more about webgl-utils.js see:');  // eslint-disable-line\n      console.log(\"%c%s\", 'color:blue;font-weight:bold;', 'https://webglfundamentals.org/webgl/lessons/webgl-boilerplate.html');  // eslint-disable-line\n    }\n  \n    /**\n     * Wrapped logging function.\n     * @param {string} msg The message to log.\n     */\n    function error(msg) {\n      if (topWindow.console) {\n        if (topWindow.console.error) {\n          topWindow.console.error(msg);\n        } else if (topWindow.console.log) {\n          topWindow.console.log(msg);\n        }\n      }\n    }\n  \n  \n    /**\n     * Error Callback\n     * @callback ErrorCallback\n     * @param {string} msg error message.\n     * @memberOf module:webgl-utils\n     */\n  \n  \n    /**\n     * Loads a shader.\n     * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n     * @param {string} shaderSource The shader source.\n     * @param {number} shaderType The type of shader.\n     * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.\n     * @return {WebGLShader} The created shader.\n     */\n    function loadShader(gl, shaderSource, shaderType, opt_errorCallback) {\n      const errFn = opt_errorCallback || error;\n      // Create the shader object\n      const shader = gl.createShader(shaderType);\n  \n      // Load the shader source\n      gl.shaderSource(shader, shaderSource);\n  \n      // Compile the shader\n      gl.compileShader(shader);\n  \n      // Check the compile status\n      const compiled = gl.getShaderParameter(shader, gl.COMPILE_STATUS);\n      if (!compiled) {\n        // Something went wrong during compilation; get the error\n        const lastError = gl.getShaderInfoLog(shader);\n        errFn('*** Error compiling shader \\'' + shader + '\\':' + lastError + `\\n` + shaderSource.split('\\n').map((l,i) => `${i + 1}: ${l}`).join('\\n'));\n        gl.deleteShader(shader);\n        return null;\n      }\n  \n      return shader;\n    }\n  \n    /**\n     * Creates a program, attaches shaders, binds attrib locations, links the\n     * program and calls useProgram.\n     * @param {WebGLShader[]} shaders The shaders to attach\n     * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n     * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n     * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n     *        on error. If you want something else pass an callback. It's passed an error message.\n     * @memberOf module:webgl-utils\n     */\n    function createProgram(\n        gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {\n      const errFn = opt_errorCallback || error;\n      const program = gl.createProgram();\n      shaders.forEach(function(shader) {\n        gl.attachShader(program, shader);\n      });\n      if (opt_attribs) {\n        opt_attribs.forEach(function(attrib, ndx) {\n          gl.bindAttribLocation(\n              program,\n              opt_locations ? opt_locations[ndx] : ndx,\n              attrib);\n        });\n      }\n      gl.linkProgram(program);\n  \n      // Check the link status\n      const linked = gl.getProgramParameter(program, gl.LINK_STATUS);\n      if (!linked) {\n          // something went wrong with the link\n          const lastError = gl.getProgramInfoLog(program);\n          errFn('Error in program linking:' + lastError);\n  \n          gl.deleteProgram(program);\n          return null;\n      }\n      return program;\n    }\n  \n    /**\n     * Loads a shader from a script tag.\n     * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.\n     * @param {string} scriptId The id of the script tag.\n     * @param {number} opt_shaderType The type of shader. If not passed in it will\n     *     be derived from the type of the script tag.\n     * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors.\n     * @return {WebGLShader} The created shader.\n     */\n    function createShaderFromScript(\n        gl, scriptId, opt_shaderType, opt_errorCallback) {\n      let shaderSource = '';\n      let shaderType;\n      const shaderScript = document.getElementById(scriptId);\n      if (!shaderScript) {\n        throw ('*** Error: unknown script element' + scriptId);\n      }\n      shaderSource = shaderScript.text;\n  \n      if (!opt_shaderType) {\n        if (shaderScript.type === 'x-shader/x-vertex') {\n          shaderType = gl.VERTEX_SHADER;\n        } else if (shaderScript.type === 'x-shader/x-fragment') {\n          shaderType = gl.FRAGMENT_SHADER;\n        } else if (shaderType !== gl.VERTEX_SHADER && shaderType !== gl.FRAGMENT_SHADER) {\n          throw ('*** Error: unknown shader type');\n        }\n      }\n  \n      return loadShader(\n          gl, shaderSource, opt_shaderType ? opt_shaderType : shaderType,\n          opt_errorCallback);\n    }\n  \n    const defaultShaderType = [\n      'VERTEX_SHADER',\n      'FRAGMENT_SHADER',\n    ];\n  \n    /**\n     * Creates a program from 2 script tags.\n     *\n     * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n     *        to use.\n     * @param {string[]} shaderScriptIds Array of ids of the script\n     *        tags for the shaders. The first is assumed to be the\n     *        vertex shader, the second the fragment shader.\n     * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n     * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n     * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n     *        on error. If you want something else pass an callback. It's passed an error message.\n     * @return {WebGLProgram} The created program.\n     * @memberOf module:webgl-utils\n     */\n    function createProgramFromScripts_original(\n        gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {\n      const shaders = [];\n      for (let ii = 0; ii < shaderScriptIds.length; ++ii) {\n        shaders.push(createShaderFromScript(\n            gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], opt_errorCallback));\n      }\n      return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);\n    }\n  \n    function createProgramFromScripts(gl, vertexShaderSource, fragmentShaderSource) {\n        // Create vertex shader\n        const vertexShader = gl.createShader(gl.VERTEX_SHADER);\n        if (!vertexShader) {\n            console.error('Failed to create vertex shader');\n            return null;\n        }\n        gl.shaderSource(vertexShader, vertexShaderSource);\n        gl.compileShader(vertexShader);\n        // Check for compilation errors...\n    \n        // Create fragment shader\n        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n        if (!fragmentShader) {\n            console.error('Failed to create fragment shader');\n            return null;\n        }\n        gl.shaderSource(fragmentShader, fragmentShaderSource);\n        gl.compileShader(fragmentShader);\n        // Check for compilation errors...\n    \n        // Create program\n        const program = gl.createProgram();\n        if (!program) {\n            console.error('Failed to create shader program');\n            return null;\n        }\n        gl.attachShader(program, vertexShader);\n        gl.attachShader(program, fragmentShader);\n        gl.linkProgram(program);\n        // Check for linking errors...\n    \n        return program;\n    }\n    \n    /**\n     * Creates a program from 2 sources.\n     *\n     * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n     *        to use.\n     * @param {string[]} shaderSourcess Array of sources for the\n     *        shaders. The first is assumed to be the vertex shader,\n     *        the second the fragment shader.\n     * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n     * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n     * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n     *        on error. If you want something else pass an callback. It's passed an error message.\n     * @return {WebGLProgram} The created program.\n     * @memberOf module:webgl-utils\n     */\n    function createProgramFromSources(\n        gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n      const shaders = [];\n      for (let ii = 0; ii < shaderSources.length; ++ii) {\n        shaders.push(loadShader(\n            gl, shaderSources[ii], gl[defaultShaderType[ii]], opt_errorCallback));\n      }\n      return createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback);\n    }\n  \n    /**\n     * Returns the corresponding bind point for a given sampler type\n     */\n    function getBindPointForSamplerType(gl, type) {\n      if (type === gl.SAMPLER_2D)   return gl.TEXTURE_2D;        // eslint-disable-line\n      if (type === gl.SAMPLER_CUBE) return gl.TEXTURE_CUBE_MAP;  // eslint-disable-line\n      return undefined;\n    }\n  \n    /**\n     * @typedef {Object.<string, function>} Setters\n     */\n  \n    /**\n     * Creates setter functions for all uniforms of a shader\n     * program.\n     *\n     * @see {@link module:webgl-utils.setUniforms}\n     *\n     * @param {WebGLProgram} program the program to create setters for.\n     * @returns {Object.<string, function>} an object with a setter by name for each uniform\n     * @memberOf module:webgl-utils\n     */\n    function createUniformSetters(gl, program) {\n      let textureUnit = 0;\n  \n      /**\n       * Creates a setter for a uniform of the given program with it's\n       * location embedded in the setter.\n       * @param {WebGLProgram} program\n       * @param {WebGLUniformInfo} uniformInfo\n       * @returns {function} the created setter.\n       */\n      function createUniformSetter(program, uniformInfo) {\n        const location = gl.getUniformLocation(program, uniformInfo.name);\n        const type = uniformInfo.type;\n        // Check if this uniform is an array\n        const isArray = (uniformInfo.size > 1 && uniformInfo.name.substr(-3) === '[0]');\n        if (type === gl.FLOAT && isArray) {\n          return function(v) {\n            gl.uniform1fv(location, v);\n          };\n        }\n        if (type === gl.FLOAT) {\n          return function(v) {\n            gl.uniform1f(location, v);\n          };\n        }\n        if (type === gl.FLOAT_VEC2) {\n          return function(v) {\n            gl.uniform2fv(location, v);\n          };\n        }\n        if (type === gl.FLOAT_VEC3) {\n          return function(v) {\n            gl.uniform3fv(location, v);\n          };\n        }\n        if (type === gl.FLOAT_VEC4) {\n          return function(v) {\n            gl.uniform4fv(location, v);\n          };\n        }\n        if (type === gl.INT && isArray) {\n          return function(v) {\n            gl.uniform1iv(location, v);\n          };\n        }\n        if (type === gl.INT) {\n          return function(v) {\n            gl.uniform1i(location, v);\n          };\n        }\n        if (type === gl.INT_VEC2) {\n          return function(v) {\n            gl.uniform2iv(location, v);\n          };\n        }\n        if (type === gl.INT_VEC3) {\n          return function(v) {\n            gl.uniform3iv(location, v);\n          };\n        }\n        if (type === gl.INT_VEC4) {\n          return function(v) {\n            gl.uniform4iv(location, v);\n          };\n        }\n        if (type === gl.BOOL) {\n          return function(v) {\n            gl.uniform1iv(location, v);\n          };\n        }\n        if (type === gl.BOOL_VEC2) {\n          return function(v) {\n            gl.uniform2iv(location, v);\n          };\n        }\n        if (type === gl.BOOL_VEC3) {\n          return function(v) {\n            gl.uniform3iv(location, v);\n          };\n        }\n        if (type === gl.BOOL_VEC4) {\n          return function(v) {\n            gl.uniform4iv(location, v);\n          };\n        }\n        if (type === gl.FLOAT_MAT2) {\n          return function(v) {\n            gl.uniformMatrix2fv(location, false, v);\n          };\n        }\n        if (type === gl.FLOAT_MAT3) {\n          return function(v) {\n            gl.uniformMatrix3fv(location, false, v);\n          };\n        }\n        if (type === gl.FLOAT_MAT4) {\n          return function(v) {\n            gl.uniformMatrix4fv(location, false, v);\n          };\n        }\n        if ((type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) && isArray) {\n          const units = [];\n          for (let ii = 0; ii < info.size; ++ii) {\n            units.push(textureUnit++);\n          }\n          return function(bindPoint, units) {\n            return function(textures) {\n              gl.uniform1iv(location, units);\n              textures.forEach(function(texture, index) {\n                gl.activeTexture(gl.TEXTURE0 + units[index]);\n                gl.bindTexture(bindPoint, texture);\n              });\n            };\n          }(getBindPointForSamplerType(gl, type), units);\n        }\n        if (type === gl.SAMPLER_2D || type === gl.SAMPLER_CUBE) {\n          return function(bindPoint, unit) {\n            return function(texture) {\n              gl.uniform1i(location, unit);\n              gl.activeTexture(gl.TEXTURE0 + unit);\n              gl.bindTexture(bindPoint, texture);\n            };\n          }(getBindPointForSamplerType(gl, type), textureUnit++);\n        }\n        throw ('unknown type: 0x' + type.toString(16)); // we should never get here.\n      }\n  \n      const uniformSetters = { };\n      const numUniforms = gl.getProgramParameter(program, gl.ACTIVE_UNIFORMS);\n  \n      for (let ii = 0; ii < numUniforms; ++ii) {\n        const uniformInfo = gl.getActiveUniform(program, ii);\n        if (!uniformInfo) {\n          break;\n        }\n        let name = uniformInfo.name;\n        // remove the array suffix.\n        if (name.substr(-3) === '[0]') {\n          name = name.substr(0, name.length - 3);\n        }\n        const setter = createUniformSetter(program, uniformInfo);\n        uniformSetters[name] = setter;\n      }\n      return uniformSetters;\n    }\n  \n    /**\n     * Set uniforms and binds related textures.\n     *\n     * Example:\n     *\n     *     let programInfo = createProgramInfo(\n     *         gl, [\"some-vs\", \"some-fs\"]);\n     *\n     *     let tex1 = gl.createTexture();\n     *     let tex2 = gl.createTexture();\n     *\n     *     ... assume we setup the textures with data ...\n     *\n     *     let uniforms = {\n     *       u_someSampler: tex1,\n     *       u_someOtherSampler: tex2,\n     *       u_someColor: [1,0,0,1],\n     *       u_somePosition: [0,1,1],\n     *       u_someMatrix: [\n     *         1,0,0,0,\n     *         0,1,0,0,\n     *         0,0,1,0,\n     *         0,0,0,0,\n     *       ],\n     *     };\n     *\n     *     gl.useProgram(program);\n     *\n     * This will automatically bind the textures AND set the\n     * uniforms.\n     *\n     *     setUniforms(programInfo.uniformSetters, uniforms);\n     *\n     * For the example above it is equivalent to\n     *\n     *     let texUnit = 0;\n     *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n     *     gl.bindTexture(gl.TEXTURE_2D, tex1);\n     *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n     *     gl.activeTexture(gl.TEXTURE0 + texUnit);\n     *     gl.bindTexture(gl.TEXTURE_2D, tex2);\n     *     gl.uniform1i(u_someSamplerLocation, texUnit++);\n     *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);\n     *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);\n     *     gl.uniformMatrix4fv(u_someMatrix, false, [\n     *         1,0,0,0,\n     *         0,1,0,0,\n     *         0,0,1,0,\n     *         0,0,0,0,\n     *       ]);\n     *\n     * Note it is perfectly reasonable to call `setUniforms` multiple times. For example\n     *\n     *     let uniforms = {\n     *       u_someSampler: tex1,\n     *       u_someOtherSampler: tex2,\n     *     };\n     *\n     *     let moreUniforms {\n     *       u_someColor: [1,0,0,1],\n     *       u_somePosition: [0,1,1],\n     *       u_someMatrix: [\n     *         1,0,0,0,\n     *         0,1,0,0,\n     *         0,0,1,0,\n     *         0,0,0,0,\n     *       ],\n     *     };\n     *\n     *     setUniforms(programInfo.uniformSetters, uniforms);\n     *     setUniforms(programInfo.uniformSetters, moreUniforms);\n     *\n     * @param {Object.<string, function>|module:webgl-utils.ProgramInfo} setters the setters returned from\n     *        `createUniformSetters` or a ProgramInfo from {@link module:webgl-utils.createProgramInfo}.\n     * @param {Object.<string, value>} an object with values for the\n     *        uniforms.\n     * @memberOf module:webgl-utils\n     */\n    function setUniforms(setters, ...values) {\n      setters = setters.uniformSetters || setters;\n      for (const uniforms of values) {\n        Object.keys(uniforms).forEach(function(name) {\n          const setter = setters[name];\n          if (setter) {\n            setter(uniforms[name]);\n          }\n        });\n      }\n    }\n  \n    /**\n     * Creates setter functions for all attributes of a shader\n     * program. You can pass this to {@link module:webgl-utils.setBuffersAndAttributes} to set all your buffers and attributes.\n     *\n     * @see {@link module:webgl-utils.setAttributes} for example\n     * @param {WebGLProgram} program the program to create setters for.\n     * @return {Object.<string, function>} an object with a setter for each attribute by name.\n     * @memberOf module:webgl-utils\n     */\n    function createAttributeSetters(gl, program) {\n      const attribSetters = {\n      };\n  \n      function createAttribSetter(index) {\n        return function(b) {\n            if (b.value) {\n              gl.disableVertexAttribArray(index);\n              switch (b.value.length) {\n                case 4:\n                  gl.vertexAttrib4fv(index, b.value);\n                  break;\n                case 3:\n                  gl.vertexAttrib3fv(index, b.value);\n                  break;\n                case 2:\n                  gl.vertexAttrib2fv(index, b.value);\n                  break;\n                case 1:\n                  gl.vertexAttrib1fv(index, b.value);\n                  break;\n                default:\n                  throw new Error('the length of a float constant value must be between 1 and 4!');\n              }\n            } else {\n              gl.bindBuffer(gl.ARRAY_BUFFER, b.buffer);\n              gl.enableVertexAttribArray(index);\n              gl.vertexAttribPointer(\n                  index, b.numComponents || b.size, b.type || gl.FLOAT, b.normalize || false, b.stride || 0, b.offset || 0);\n            }\n          };\n      }\n  \n      const numAttribs = gl.getProgramParameter(program, gl.ACTIVE_ATTRIBUTES);\n      for (let ii = 0; ii < numAttribs; ++ii) {\n        const attribInfo = gl.getActiveAttrib(program, ii);\n        if (!attribInfo) {\n          break;\n        }\n        const index = gl.getAttribLocation(program, attribInfo.name);\n        attribSetters[attribInfo.name] = createAttribSetter(index);\n      }\n  \n      return attribSetters;\n    }\n  \n    /**\n     * Sets attributes and binds buffers (deprecated... use {@link module:webgl-utils.setBuffersAndAttributes})\n     *\n     * Example:\n     *\n     *     let program = createProgramFromScripts(\n     *         gl, [\"some-vs\", \"some-fs\"]);\n     *\n     *     let attribSetters = createAttributeSetters(program);\n     *\n     *     let positionBuffer = gl.createBuffer();\n     *     let texcoordBuffer = gl.createBuffer();\n     *\n     *     let attribs = {\n     *       a_position: {buffer: positionBuffer, numComponents: 3},\n     *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n     *     };\n     *\n     *     gl.useProgram(program);\n     *\n     * This will automatically bind the buffers AND set the\n     * attributes.\n     *\n     *     setAttributes(attribSetters, attribs);\n     *\n     * Properties of attribs. For each attrib you can add\n     * properties:\n     *\n     * *   type: the type of data in the buffer. Default = gl.FLOAT\n     * *   normalize: whether or not to normalize the data. Default = false\n     * *   stride: the stride. Default = 0\n     * *   offset: offset into the buffer. Default = 0\n     *\n     * For example if you had 3 value float positions, 2 value\n     * float texcoord and 4 value uint8 colors you'd setup your\n     * attribs like this\n     *\n     *     let attribs = {\n     *       a_position: {buffer: positionBuffer, numComponents: 3},\n     *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},\n     *       a_color: {\n     *         buffer: colorBuffer,\n     *         numComponents: 4,\n     *         type: gl.UNSIGNED_BYTE,\n     *         normalize: true,\n     *       },\n     *     };\n     *\n     * @param {Object.<string, function>|model:webgl-utils.ProgramInfo} setters Attribute setters as returned from createAttributeSetters or a ProgramInfo as returned {@link module:webgl-utils.createProgramInfo}\n     * @param {Object.<string, module:webgl-utils.AttribInfo>} attribs AttribInfos mapped by attribute name.\n     * @memberOf module:webgl-utils\n     * @deprecated use {@link module:webgl-utils.setBuffersAndAttributes}\n     */\n    function setAttributes(setters, attribs) {\n      setters = setters.attribSetters || setters;\n      Object.keys(attribs).forEach(function(name) {\n        const setter = setters[name];\n        if (setter) {\n          setter(attribs[name]);\n        }\n      });\n    }\n  \n    /**\n     * Creates a vertex array object and then sets the attributes\n     * on it\n     *\n     * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n     *        to use.\n     * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters\n     * @param {Object.<string, module:webgl-utils.AttribInfo>} attribs AttribInfos mapped by attribute name.\n     * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices\n     */\n    function createVAOAndSetAttributes(gl, setters, attribs, indices) {\n      const vao = gl.createVertexArray();\n      gl.bindVertexArray(vao);\n      setAttributes(setters, attribs);\n      if (indices) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indices);\n      }\n      // We unbind this because otherwise any change to ELEMENT_ARRAY_BUFFER\n      // like when creating buffers for other stuff will mess up this VAO's binding\n      gl.bindVertexArray(null);\n      return vao;\n    }\n  \n    /**\n     * Creates a vertex array object and then sets the attributes\n     * on it\n     *\n     * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n     *        to use.\n     * @param {Object.<string, function>| module:webgl-utils.ProgramInfo} programInfo as returned from createProgramInfo or Attribute setters as returned from createAttributeSetters\n     * @param {module:webgl-utils:BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...\n     * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices\n     */\n    function createVAOFromBufferInfo(gl, programInfo, bufferInfo) {\n      return createVAOAndSetAttributes(gl, programInfo.attribSetters || programInfo, bufferInfo.attribs, bufferInfo.indices);\n    }\n  \n    /**\n     * @typedef {Object} ProgramInfo\n     * @property {WebGLProgram} program A shader program\n     * @property {Object<string, function>} uniformSetters: object of setters as returned from createUniformSetters,\n     * @property {Object<string, function>} attribSetters: object of setters as returned from createAttribSetters,\n     * @memberOf module:webgl-utils\n     */\n  \n    /**\n     * Creates a ProgramInfo from 2 sources.\n     *\n     * A ProgramInfo contains\n     *\n     *     programInfo = {\n     *        program: WebGLProgram,\n     *        uniformSetters: object of setters as returned from createUniformSetters,\n     *        attribSetters: object of setters as returned from createAttribSetters,\n     *     }\n     *\n     * @param {WebGLRenderingContext} gl The WebGLRenderingContext\n     *        to use.\n     * @param {string[]} shaderSourcess Array of sources for the\n     *        shaders or ids. The first is assumed to be the vertex shader,\n     *        the second the fragment shader.\n     * @param {string[]} [opt_attribs] An array of attribs names. Locations will be assigned by index if not passed in\n     * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.\n     * @param {module:webgl-utils.ErrorCallback} opt_errorCallback callback for errors. By default it just prints an error to the console\n     *        on error. If you want something else pass an callback. It's passed an error message.\n     * @return {module:webgl-utils.ProgramInfo} The created program.\n     * @memberOf module:webgl-utils\n     */\n    function createProgramInfo(\n        gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {\n      shaderSources = shaderSources.map(function(source) {\n        const script = document.getElementById(source);\n        return script ? script.text : source;\n      });\n      const program = webglUtils.createProgramFromSources(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback);\n      if (!program) {\n        return null;\n      }\n      const uniformSetters = createUniformSetters(gl, program);\n      const attribSetters = createAttributeSetters(gl, program);\n      return {\n        program: program,\n        uniformSetters: uniformSetters,\n        attribSetters: attribSetters,\n      };\n    }\n  \n    /**\n     * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate\n     *\n     * Example:\n     *\n     *     let programInfo = createProgramInfo(\n     *         gl, [\"some-vs\", \"some-fs\"]);\n     *\n     *     let arrays = {\n     *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n     *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n     *     };\n     *\n     *     let bufferInfo = createBufferInfoFromArrays(gl, arrays);\n     *\n     *     gl.useProgram(programInfo.program);\n     *\n     * This will automatically bind the buffers AND set the\n     * attributes.\n     *\n     *     setBuffersAndAttributes(programInfo.attribSetters, bufferInfo);\n     *\n     * For the example above it is equivilent to\n     *\n     *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n     *     gl.enableVertexAttribArray(a_positionLocation);\n     *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);\n     *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n     *     gl.enableVertexAttribArray(a_texcoordLocation);\n     *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);\n     *\n     * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n     * @param {Object.<string, function>} setters Attribute setters as returned from `createAttributeSetters`\n     * @param {module:webgl-utils.BufferInfo} buffers a BufferInfo as returned from `createBufferInfoFromArrays`.\n     * @memberOf module:webgl-utils\n     */\n    function setBuffersAndAttributes(gl, setters, buffers) {\n      setAttributes(setters, buffers.attribs);\n      if (buffers.indices) {\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, buffers.indices);\n      }\n    }\n  \n    // Add your prefix here.\n    const browserPrefixes = [\n      '',\n      'MOZ_',\n      'OP_',\n      'WEBKIT_',\n    ];\n  \n    /**\n     * Given an extension name like WEBGL_compressed_texture_s3tc\n     * returns the supported version extension, like\n     * WEBKIT_WEBGL_compressed_teture_s3tc\n     * @param {string} name Name of extension to look for\n     * @return {WebGLExtension} The extension or undefined if not\n     *     found.\n     * @memberOf module:webgl-utils\n     */\n    function getExtensionWithKnownPrefixes(gl, name) {\n      for (let ii = 0; ii < browserPrefixes.length; ++ii) {\n        const prefixedName = browserPrefixes[ii] + name;\n        const ext = gl.getExtension(prefixedName);\n        if (ext) {\n          return ext;\n        }\n      }\n      return undefined;\n    }\n  \n    /**\n     * Resize a canvas to match the size its displayed.\n     * @param {HTMLCanvasElement} canvas The canvas to resize.\n     * @param {number} [multiplier] amount to multiply by.\n     *    Pass in window.devicePixelRatio for native pixels.\n     * @return {boolean} true if the canvas was resized.\n     * @memberOf module:webgl-utils\n     */\n    function resizeCanvasToDisplaySize(canvas, multiplier) {\n      multiplier = multiplier || 1;\n      const width  = canvas.clientWidth  * multiplier | 0;\n      const height = canvas.clientHeight * multiplier | 0;\n      if (canvas.width !== width ||  canvas.height !== height) {\n        canvas.width  = width;\n        canvas.height = height;\n        return true;\n      }\n      return false;\n    }\n  \n    // Add `push` to a typed array. It just keeps a 'cursor'\n    // and allows use to `push` values into the array so we\n    // don't have to manually compute offsets\n    function augmentTypedArray(typedArray, numComponents) {\n      let cursor = 0;\n      typedArray.push = function() {\n        for (let ii = 0; ii < arguments.length; ++ii) {\n          const value = arguments[ii];\n          if (value instanceof Array || (value.buffer && value.buffer instanceof ArrayBuffer)) {\n            for (let jj = 0; jj < value.length; ++jj) {\n              typedArray[cursor++] = value[jj];\n            }\n          } else {\n            typedArray[cursor++] = value;\n          }\n        }\n      };\n      typedArray.reset = function(opt_index) {\n        cursor = opt_index || 0;\n      };\n      typedArray.numComponents = numComponents;\n      Object.defineProperty(typedArray, 'numElements', {\n        get: function() {\n          return this.length / this.numComponents | 0;\n        },\n      });\n      return typedArray;\n    }\n  \n    /**\n     * creates a typed array with a `push` function attached\n     * so that you can easily *push* values.\n     *\n     * `push` can take multiple arguments. If an argument is an array each element\n     * of the array will be added to the typed array.\n     *\n     * Example:\n     *\n     *     let array = createAugmentedTypedArray(3, 2);  // creates a Float32Array with 6 values\n     *     array.push(1, 2, 3);\n     *     array.push([4, 5, 6]);\n     *     // array now contains [1, 2, 3, 4, 5, 6]\n     *\n     * Also has `numComponents` and `numElements` properties.\n     *\n     * @param {number} numComponents number of components\n     * @param {number} numElements number of elements. The total size of the array will be `numComponents * numElements`.\n     * @param {constructor} opt_type A constructor for the type. Default = `Float32Array`.\n     * @return {ArrayBuffer} A typed array.\n     * @memberOf module:webgl-utils\n     */\n    function createAugmentedTypedArray(numComponents, numElements, opt_type) {\n      const Type = opt_type || Float32Array;\n      return augmentTypedArray(new Type(numComponents * numElements), numComponents);\n    }\n  \n    function createBufferFromTypedArray(gl, array, type, drawType) {\n      type = type || gl.ARRAY_BUFFER;\n      const buffer = gl.createBuffer();\n      gl.bindBuffer(type, buffer);\n      gl.bufferData(type, array, drawType || gl.STATIC_DRAW);\n      return buffer;\n    }\n  \n    function allButIndices(name) {\n      return name !== 'indices';\n    }\n  \n    function createMapping(obj) {\n      const mapping = {};\n      Object.keys(obj).filter(allButIndices).forEach(function(key) {\n        mapping['a_' + key] = key;\n      });\n      return mapping;\n    }\n  \n    function getGLTypeForTypedArray(gl, typedArray) {\n      if (typedArray instanceof Int8Array)    { return gl.BYTE; }            // eslint-disable-line\n      if (typedArray instanceof Uint8Array)   { return gl.UNSIGNED_BYTE; }   // eslint-disable-line\n      if (typedArray instanceof Int16Array)   { return gl.SHORT; }           // eslint-disable-line\n      if (typedArray instanceof Uint16Array)  { return gl.UNSIGNED_SHORT; }  // eslint-disable-line\n      if (typedArray instanceof Int32Array)   { return gl.INT; }             // eslint-disable-line\n      if (typedArray instanceof Uint32Array)  { return gl.UNSIGNED_INT; }    // eslint-disable-line\n      if (typedArray instanceof Float32Array) { return gl.FLOAT; }           // eslint-disable-line\n      throw 'unsupported typed array type';\n    }\n  \n    // This is really just a guess. Though I can't really imagine using\n    // anything else? Maybe for some compression?\n    function getNormalizationForTypedArray(typedArray) {\n      if (typedArray instanceof Int8Array)    { return true; }  // eslint-disable-line\n      if (typedArray instanceof Uint8Array)   { return true; }  // eslint-disable-line\n      return false;\n    }\n  \n    function isArrayBuffer(a) {\n      return a.buffer && a.buffer instanceof ArrayBuffer;\n    }\n  \n    function guessNumComponentsFromName(name, length) {\n      let numComponents;\n      if (name.indexOf('coord') >= 0) {\n        numComponents = 2;\n      } else if (name.indexOf('color') >= 0) {\n        numComponents = 4;\n      } else {\n        numComponents = 3;  // position, normals, indices ...\n      }\n  \n      if (length % numComponents > 0) {\n        throw 'can not guess numComponents. You should specify it.';\n      }\n  \n      return numComponents;\n    }\n  \n    function makeTypedArray(array, name) {\n      if (isArrayBuffer(array)) {\n        return array;\n      }\n  \n      if (array.data && isArrayBuffer(array.data)) {\n        return array.data;\n      }\n  \n      if (Array.isArray(array)) {\n        array = {\n          data: array,\n        };\n      }\n  \n      if (!array.numComponents) {\n        array.numComponents = guessNumComponentsFromName(name, array.length);\n      }\n  \n      let type = array.type;\n      if (!type) {\n        if (name === 'indices') {\n          type = Uint16Array;\n        }\n      }\n      const typedArray = createAugmentedTypedArray(array.numComponents, array.data.length / array.numComponents | 0, type);\n      typedArray.push(array.data);\n      return typedArray;\n    }\n  \n    /**\n     * @typedef {Object} AttribInfo\n     * @property {number} [numComponents] the number of components for this attribute.\n     * @property {number} [size] the number of components for this attribute.\n     * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`\n     * @property {boolean} [normalized] whether or not to normalize the data. Default = false\n     * @property {number} [offset] offset into buffer in bytes. Default = 0\n     * @property {number} [stride] the stride in bytes per element. Default = 0\n     * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute\n     * @memberOf module:webgl-utils\n     */\n  \n  \n    /**\n     * Creates a set of attribute data and WebGLBuffers from set of arrays\n     *\n     * Given\n     *\n     *      let arrays = {\n     *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n     *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n     *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n     *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },\n     *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n     *      };\n     *\n     * returns something like\n     *\n     *      let attribs = {\n     *        a_position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n     *        a_texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n     *        a_normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },\n     *        a_color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },\n     *      };\n     *\n     * @param {WebGLRenderingContext} gl The webgl rendering context.\n     * @param {Object.<string, array|typedarray>} arrays The arrays\n     * @param {Object.<string, string>} [opt_mapping] mapping from attribute name to array name.\n     *     if not specified defaults to \"a_name\" -> \"name\".\n     * @return {Object.<string, module:webgl-utils.AttribInfo>} the attribs\n     * @memberOf module:webgl-utils\n     */\n    function createAttribsFromArrays(gl, arrays, opt_mapping) {\n      const mapping = opt_mapping || createMapping(arrays);\n      const attribs = {};\n      Object.keys(mapping).forEach(function(attribName) {\n        const bufferName = mapping[attribName];\n        const origArray = arrays[bufferName];\n        if (origArray.value) {\n          attribs[attribName] = {\n            value: origArray.value,\n          };\n        } else {\n          const array = makeTypedArray(origArray, bufferName);\n          attribs[attribName] = {\n            buffer:        createBufferFromTypedArray(gl, array),\n            numComponents: origArray.numComponents || array.numComponents || guessNumComponentsFromName(bufferName),\n            type:          getGLTypeForTypedArray(gl, array),\n            normalize:     getNormalizationForTypedArray(array),\n          };\n        }\n      });\n      return attribs;\n    }\n  \n    function getArray(array) {\n      return array.length ? array : array.data;\n    }\n  \n    const texcoordRE = /coord|texture/i;\n    const colorRE = /color|colour/i;\n  \n    function guessNumComponentsFromName(name, length) {\n      let numComponents;\n      if (texcoordRE.test(name)) {\n        numComponents = 2;\n      } else if (colorRE.test(name)) {\n        numComponents = 4;\n      } else {\n        numComponents = 3;  // position, normals, indices ...\n      }\n  \n      if (length % numComponents > 0) {\n        throw new Error(`Can not guess numComponents for attribute '${name}'. Tried ${numComponents} but ${length} values is not evenly divisible by ${numComponents}. You should specify it.`);\n      }\n  \n      return numComponents;\n    }\n  \n    function getNumComponents(array, arrayName) {\n      return array.numComponents || array.size || guessNumComponentsFromName(arrayName, getArray(array).length);\n    }\n  \n    /**\n     * tries to get the number of elements from a set of arrays.\n     */\n    const positionKeys = ['position', 'positions', 'a_position'];\n    function getNumElementsFromNonIndexedArrays(arrays) {\n      let key;\n      for (const k of positionKeys) {\n        if (k in arrays) {\n          key = k;\n          break;\n        }\n      }\n      key = key || Object.keys(arrays)[0];\n      const array = arrays[key];\n      const length = getArray(array).length;\n      const numComponents = getNumComponents(array, key);\n      const numElements = length / numComponents;\n      if (length % numComponents > 0) {\n        throw new Error(`numComponents ${numComponents} not correct for length ${length}`);\n      }\n      return numElements;\n    }\n  \n    /**\n     * @typedef {Object} BufferInfo\n     * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.\n     * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.\n     * @property {Object.<string, module:webgl-utils.AttribInfo>} attribs The attribs approriate to call `setAttributes`\n     * @memberOf module:webgl-utils\n     */\n  \n  \n    /**\n     * Creates a BufferInfo from an object of arrays.\n     *\n     * This can be passed to {@link module:webgl-utils.setBuffersAndAttributes} and to\n     * {@link module:webgl-utils:drawBufferInfo}.\n     *\n     * Given an object like\n     *\n     *     let arrays = {\n     *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },\n     *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },\n     *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },\n     *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },\n     *     };\n     *\n     *  Creates an BufferInfo like this\n     *\n     *     bufferInfo = {\n     *       numElements: 4,        // or whatever the number of elements is\n     *       indices: WebGLBuffer,  // this property will not exist if there are no indices\n     *       attribs: {\n     *         a_position: { buffer: WebGLBuffer, numComponents: 3, },\n     *         a_normal:   { buffer: WebGLBuffer, numComponents: 3, },\n     *         a_texcoord: { buffer: WebGLBuffer, numComponents: 2, },\n     *       },\n     *     };\n     *\n     *  The properties of arrays can be JavaScript arrays in which case the number of components\n     *  will be guessed.\n     *\n     *     let arrays = {\n     *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],\n     *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],\n     *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],\n     *        indices:  [0, 1, 2, 1, 2, 3],\n     *     };\n     *\n     *  They can also by TypedArrays\n     *\n     *     let arrays = {\n     *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),\n     *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),\n     *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),\n     *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),\n     *     };\n     *\n     *  Or augmentedTypedArrays\n     *\n     *     let positions = createAugmentedTypedArray(3, 4);\n     *     let texcoords = createAugmentedTypedArray(2, 4);\n     *     let normals   = createAugmentedTypedArray(3, 4);\n     *     let indices   = createAugmentedTypedArray(3, 2, Uint16Array);\n     *\n     *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);\n     *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);\n     *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);\n     *     indices.push([0, 1, 2, 1, 2, 3]);\n     *\n     *     let arrays = {\n     *        position: positions,\n     *        texcoord: texcoords,\n     *        normal:   normals,\n     *        indices:  indices,\n     *     };\n     *\n     * For the last example it is equivalent to\n     *\n     *     let bufferInfo = {\n     *       attribs: {\n     *         a_position: { numComponents: 3, buffer: gl.createBuffer(), },\n     *         a_texcoods: { numComponents: 2, buffer: gl.createBuffer(), },\n     *         a_normals: { numComponents: 3, buffer: gl.createBuffer(), },\n     *       },\n     *       indices: gl.createBuffer(),\n     *       numElements: 6,\n     *     };\n     *\n     *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_position.buffer);\n     *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);\n     *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_texcoord.buffer);\n     *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);\n     *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.a_normal.buffer);\n     *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);\n     *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);\n     *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);\n     *\n     * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n     * @param {Object.<string, array|object|typedarray>} arrays Your data\n     * @param {Object.<string, string>} [opt_mapping] an optional mapping of attribute to array name.\n     *    If not passed in it's assumed the array names will be mapped to an attribute\n     *    of the same name with \"a_\" prefixed to it. An other words.\n     *\n     *        let arrays = {\n     *           position: ...,\n     *           texcoord: ...,\n     *           normal:   ...,\n     *           indices:  ...,\n     *        };\n     *\n     *        bufferInfo = createBufferInfoFromArrays(gl, arrays);\n     *\n     *    Is the same as\n     *\n     *        let arrays = {\n     *           position: ...,\n     *           texcoord: ...,\n     *           normal:   ...,\n     *           indices:  ...,\n     *        };\n     *\n     *        let mapping = {\n     *          a_position: \"position\",\n     *          a_texcoord: \"texcoord\",\n     *          a_normal:   \"normal\",\n     *        };\n     *\n     *        bufferInfo = createBufferInfoFromArrays(gl, arrays, mapping);\n     *\n     * @return {module:webgl-utils.BufferInfo} A BufferInfo\n     * @memberOf module:webgl-utils\n     */\n    function createBufferInfoFromArrays(gl, arrays, opt_mapping) {\n      const bufferInfo = {\n        attribs: createAttribsFromArrays(gl, arrays, opt_mapping),\n      };\n      let indices = arrays.indices;\n      if (indices) {\n        indices = makeTypedArray(indices, 'indices');\n        bufferInfo.indices = createBufferFromTypedArray(gl, indices, gl.ELEMENT_ARRAY_BUFFER);\n        bufferInfo.numElements = indices.length;\n      } else {\n        bufferInfo.numElements = getNumElementsFromNonIndexedArrays(arrays);\n      }\n  \n      return bufferInfo;\n    }\n  \n    /**\n     * Creates buffers from typed arrays\n     *\n     * Given something like this\n     *\n     *     let arrays = {\n     *        positions: [1, 2, 3],\n     *        normals: [0, 0, 1],\n     *     }\n     *\n     * returns something like\n     *\n     *     buffers = {\n     *       positions: WebGLBuffer,\n     *       normals: WebGLBuffer,\n     *     }\n     *\n     * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.\n     *\n     * @param {WebGLRenderingContext} gl A WebGLRenderingContext.\n     * @param {Object<string, array|typedarray>} arrays\n     * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array\n     * @memberOf module:webgl-utils\n     */\n    function createBuffersFromArrays(gl, arrays) {\n      const buffers = { };\n      Object.keys(arrays).forEach(function(key) {\n        const type = key === 'indices' ? gl.ELEMENT_ARRAY_BUFFER : gl.ARRAY_BUFFER;\n        const array = makeTypedArray(arrays[key], name);\n        buffers[key] = createBufferFromTypedArray(gl, array, type);\n      });\n  \n      // hrm\n      if (arrays.indices) {\n        buffers.numElements = arrays.indices.length;\n      } else if (arrays.position) {\n        buffers.numElements = arrays.position.length / 3;\n      }\n  \n      return buffers;\n    }\n  \n    /**\n     * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate\n     *\n     * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself\n     * but calling this means if you switch from indexed data to non-indexed\n     * data you don't have to remember to update your draw call.\n     *\n     * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n     * @param {module:webgl-utils.BufferInfo} bufferInfo as returned from createBufferInfoFromArrays\n     * @param {enum} [primitiveType] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...)\n     * @param {number} [count] An optional count. Defaults to bufferInfo.numElements\n     * @param {number} [offset] An optional offset. Defaults to 0.\n     * @memberOf module:webgl-utils\n     */\n    function drawBufferInfo(gl, bufferInfo, primitiveType, count, offset) {\n      const indices = bufferInfo.indices;\n      primitiveType = primitiveType === undefined ? gl.TRIANGLES : primitiveType;\n      const numElements = count === undefined ? bufferInfo.numElements : count;\n      offset = offset === undefined ? 0 : offset;\n      if (indices) {\n        gl.drawElements(primitiveType, numElements, gl.UNSIGNED_SHORT, offset);\n      } else {\n        gl.drawArrays(primitiveType, offset, numElements);\n      }\n    }\n  \n    /**\n     * @typedef {Object} DrawObject\n     * @property {module:webgl-utils.ProgramInfo} programInfo A ProgramInfo as returned from createProgramInfo\n     * @property {module:webgl-utils.BufferInfo} bufferInfo A BufferInfo as returned from createBufferInfoFromArrays\n     * @property {Object<string, ?>} uniforms The values for the uniforms\n     * @memberOf module:webgl-utils\n     */\n  \n    /**\n     * Draws a list of objects\n     * @param {WebGLRenderingContext} gl A WebGLRenderingContext\n     * @param {DrawObject[]} objectsToDraw an array of objects to draw.\n     * @memberOf module:webgl-utils\n     */\n    function drawObjectList(gl, objectsToDraw) {\n      let lastUsedProgramInfo = null;\n      let lastUsedBufferInfo = null;\n  \n      objectsToDraw.forEach(function(object) {\n        const programInfo = object.programInfo;\n        const bufferInfo = object.bufferInfo;\n        let bindBuffers = false;\n  \n        if (programInfo !== lastUsedProgramInfo) {\n          lastUsedProgramInfo = programInfo;\n          gl.useProgram(programInfo.program);\n          bindBuffers = true;\n        }\n  \n        // Setup all the needed attributes.\n        if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {\n          lastUsedBufferInfo = bufferInfo;\n          setBuffersAndAttributes(gl, programInfo.attribSetters, bufferInfo);\n        }\n  \n        // Set the uniforms.\n        setUniforms(programInfo.uniformSetters, object.uniforms);\n  \n        // Draw\n        drawBufferInfo(gl, bufferInfo);\n      });\n    }\n  \n    function glEnumToString(gl, v) {\n      const results = [];\n      for (const key in gl) {\n        if (gl[key] === v) {\n          results.push(key);\n        }\n      }\n      return results.length\n          ? results.join(' | ')\n          : `0x${v.toString(16)}`;\n    }\n  \n    const isIE = /*@cc_on!@*/false || !!document.documentMode;\n    // Edge 20+\n    const isEdge = !isIE && !!window.StyleMedia;\n    if (isEdge) {\n      // Hack for Edge. Edge's WebGL implmentation is crap still and so they\n      // only respond to \"experimental-webgl\". I don't want to clutter the\n      // examples with that so his hack works around it\n      HTMLCanvasElement.prototype.getContext = function(origFn) {\n        return function() {\n          let args = arguments;\n          const type = args[0];\n          if (type === 'webgl') {\n            args = [].slice.call(arguments);\n            args[0] = 'experimental-webgl';\n          }\n          return origFn.apply(this, args);\n        };\n      }(HTMLCanvasElement.prototype.getContext);\n    }\n  \n    return {\n      createAugmentedTypedArray: createAugmentedTypedArray,\n      createAttribsFromArrays: createAttribsFromArrays,\n      createBuffersFromArrays: createBuffersFromArrays,\n      createBufferInfoFromArrays: createBufferInfoFromArrays,\n      createAttributeSetters: createAttributeSetters,\n      createProgram: createProgram,\n      createProgramFromScripts: createProgramFromScripts,\n      createProgramFromSources: createProgramFromSources,\n      createProgramInfo: createProgramInfo,\n      createUniformSetters: createUniformSetters,\n      createVAOAndSetAttributes: createVAOAndSetAttributes,\n      createVAOFromBufferInfo: createVAOFromBufferInfo,\n      drawBufferInfo: drawBufferInfo,\n      drawObjectList: drawObjectList,\n      glEnumToString: glEnumToString,\n      getExtensionWithKnownPrefixes: getExtensionWithKnownPrefixes,\n      resizeCanvasToDisplaySize: resizeCanvasToDisplaySize,\n      setAttributes: setAttributes,\n      setBuffersAndAttributes: setBuffersAndAttributes,\n      setUniforms: setUniforms,\n    };\n  \n  }));","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","const webglUtils  = require(\"./webgl-utils\")\n\n\n\n// REFERENCE: https://webglfundamentals.org/webgl/lessons/webgl-3d-textures.html\nfunction render(image, canvasEle, shaderCode=null) {\n    /** @type {HTMLCanvasElement} */\n    var canvas = canvasEle;//document.getElementById(\"glCanvas\");\n    var gl = canvas.getContext(\"webgl\");\n    if (!gl) {\n        return;\n    }\n\n    const vertexShader = shaderCode?.vertex ? shaderCode.vertex : `attribute vec2 a_position;\n    attribute vec2 a_texCoord;\n    \n    uniform vec2 u_resolution;\n    \n    varying vec2 v_texCoord;\n    \n    void main() {\n       // convert the rectangle from pixels to 0.0 to 1.0\n       vec2 zeroToOne = a_position / u_resolution;\n    \n       // convert from 0->1 to 0->2\n       vec2 zeroToTwo = zeroToOne * 2.0;\n    \n       // convert from 0->2 to -1->+1 (clipspace)\n       vec2 clipSpace = zeroToTwo - 1.0;\n    \n       gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n    \n       // pass the texCoord to the fragment shader\n       // The GPU will interpolate this value between points.\n       v_texCoord = a_texCoord;\n    }`;\n\n    const fragmentShader = shaderCode?.fragment ? shaderCode.fragment : `precision mediump float;\n\n    // our texture\n    uniform sampler2D u_image;\n    uniform vec2 iResolution;\n    // the texCoords passed in from the vertex shader.\n    varying vec2 v_texCoord;\n    \n    void main() {\n        vec2 uv = gl_FragCoord.xy / iResolution;\n    \n        // get pixel information from uv location\n        vec4 texColor = texture2D(u_image, v_texCoord).bgra;\n    \n        float intensity = fract(texColor.x * texColor.y * 2.5);\n    \n        //gl_FragColor = texture2D(u_image, v_texCoord).bgra;\n        vec4 color;\n        if (intensity > 0.8)\n            color = vec4(texColor.rgb, 1.0);\n        else if (intensity > 0.5)\n            color = vec4(texColor.rgb, .9);\n        else if (intensity > 0.25)\n            color = vec4(texColor.rgb, .4);\n        else\n            color = vec4(texColor.rgb, .5);\n        \n        float grayScale = (texColor.r + texColor.g + texColor.b) / 3.0;\n        gl_FragColor = vec4(grayScale, texColor.gb * 1.8, 1.0);\n    \n       \n    }`;\n\n    // setup GLSL program\n    var program = webglUtils.createProgramFromScripts(gl,\n        vertexShader, fragmentShader\n        \n    );\n\n    // look up where the vertex data needs to go.\n    var positionLocation = gl.getAttribLocation(program, \"a_position\");\n    var texcoordLocation = gl.getAttribLocation(program, \"a_texCoord\");\n\n    // Create a buffer to put three 2d clip space points in\n    var positionBuffer = gl.createBuffer();\n\n    // Bind it to ARRAY_BUFFER (think of it as ARRAY_BUFFER = positionBuffer)\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n    // Set a rectangle the same size as the image.\n    setRectangle(gl, 0, 0, image.width, image.height);\n\n    // provide texture coordinates for the rectangle.\n    var texcoordBuffer = gl.createBuffer();\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        0.0, 0.0,\n        1.0, 0.0,\n        0.0, 1.0,\n        0.0, 1.0,\n        1.0, 0.0,\n        1.0, 1.0,\n    ]), gl.STATIC_DRAW);\n\n    // Create a texture.\n    var texture = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, texture);\n\n    // Set the parameters so we can render any size image.\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);\n\n    // Upload the image into the texture.\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);\n\n    // lookup uniforms\n    var resolutionLocation = gl.getUniformLocation(program, \"u_resolution\");\n\n    webglUtils.resizeCanvasToDisplaySize(gl.canvas);\n\n    // Tell WebGL how to convert from clip space to pixels\n    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);\n\n    // Clear the canvas\n    gl.clearColor(0, 0, 0, 0);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    // Tell it to use our program (pair of shaders)\n    gl.useProgram(program);\n\n    // Turn on the position attribute\n    gl.enableVertexAttribArray(positionLocation);\n\n    // Bind the position buffer.\n    gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);\n\n    // Tell the position attribute how to get data out of positionBuffer (ARRAY_BUFFER)\n    var size = 2;          // 2 components per iteration\n    var type = gl.FLOAT;   // the data is 32bit floats\n    var normalize = false; // don't normalize the data\n    var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position\n    var offset = 0;        // start at the beginning of the buffer\n    gl.vertexAttribPointer(\n        positionLocation, size, type, normalize, stride, offset);\n\n    // Turn on the texcoord attribute\n    gl.enableVertexAttribArray(texcoordLocation);\n\n    // bind the texcoord buffer.\n    gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);\n\n    // Tell the texcoord attribute how to get data out of texcoordBuffer (ARRAY_BUFFER)\n    var size = 2;          // 2 components per iteration\n    var type = gl.FLOAT;   // the data is 32bit floats\n    var normalize = false; // don't normalize the data\n    var stride = 0;        // 0 = move forward size * sizeof(type) each iteration to get the next position\n    var offset = 0;        // start at the beginning of the buffer\n    gl.vertexAttribPointer(\n        texcoordLocation, size, type, normalize, stride, offset);\n\n    // set the resolution\n    gl.uniform2f(resolutionLocation, gl.canvas.width, gl.canvas.height);\n\n    // Draw the rectangle.\n    var primitiveType = gl.TRIANGLES;\n    var offset = 0;\n    var count = 6;\n    gl.drawArrays(primitiveType, offset, count);\n}\n\nfunction setRectangle(gl, x, y ,width, height) {\n    var x1 = x;\n    var x2 = x + width;\n    var y1 = y;\n    var y2 = y + height;\n    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([\n        x1, y1,\n        x2, y1,\n        x1, y2,\n        x1, y2,\n        x2, y1,\n        x2, y2,\n    ]), gl.STATIC_DRAW);\n}\n\n\nexport const paint = (fileName, canvas, shaderCode=null) => {\n    const image = new Image();\n    if (canvas.width && !Number.isNaN(canvas.width)) {\n        image.width = canvas.width;\n    }\n    \n    if (canvas.height && !Number.isNaN(canvas.height)) {\n        image.height = canvas.height;\n    }\n    \n    image.src = fileName;\n    image.onload = function () {\n        render(image, canvas, shaderCode);\n    };\n}\n\n\n","export const FlatGrayConvert = {\n    vertex: `attribute vec2 a_position;\n    attribute vec2 a_texCoord;\n    \n    uniform vec2 u_resolution;\n    \n    varying vec2 v_texCoord;\n    \n    void main() {\n       // convert the rectangle from pixels to 0.0 to 1.0\n       vec2 zeroToOne =  a_position * vec2(1.0) / u_resolution;\n    \n       // convert from 0->1 to 0->2\n       vec2 zeroToTwo = zeroToOne * 2.0;\n    \n       // convert from 0->2 to -1->+1 (clipspace)\n       vec2 clipSpace = zeroToTwo - 1.0;\n    \n       gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n    \n       // pass the texCoord to the fragment shader\n       // The GPU will interpolate this value between points.\n       v_texCoord = a_texCoord;\n    }`,\n    fragment: `precision mediump float;\n\n    // our texture\n    uniform sampler2D u_image;\n    uniform vec2 iResolution;\n    // the texCoords passed in from the vertex shader.\n    varying vec2 v_texCoord;\n    \n    void main() {\n        vec2 uv = gl_FragCoord.xy / iResolution * 20.0;\n    \n        // get pixel information from uv location\n        vec4 texColor = texture2D(u_image, v_texCoord).bgra;\n    \n        float grayScale = (texColor.r + texColor.g + texColor.b) / 3.0;\n        // float intensity = fract(texColor.x * texColor.y * .524584);\n        float intensity = fract(grayScale * 0.5378785741);\n    \n        //gl_FragColor = texture2D(u_image, v_texCoord).bgra;\n        vec4 color;\n\n        if (intensity > 0.5)\n            color = vec4(grayScale,grayScale,grayScale, 1.0);\n        else if (intensity > 0.25)\n            color = vec4(0.2, 0.3, 0.3, 1.0);\n        else\n            color = vec4(0.1, .10, .10, 1.0);\n        \n        gl_FragColor = color;\n    \n       \n    }`\n    }","export const GrayScaleConverter = {\n    vertex: `attribute vec2 a_position;\n    attribute vec2 a_texCoord;\n    \n    uniform vec2 u_resolution;\n    \n    varying vec2 v_texCoord;\n    \n    void main() {\n       // convert the rectangle from pixels to 0.0 to 1.0\n       vec2 zeroToOne =  a_position * vec2(1.0) / u_resolution;\n    \n       // convert from 0->1 to 0->2\n       vec2 zeroToTwo = zeroToOne * 2.0;\n    \n       // convert from 0->2 to -1->+1 (clipspace)\n       vec2 clipSpace = zeroToTwo - 1.0;\n    \n       gl_Position = vec4(clipSpace * vec2(1, -1), 0, 1);\n    \n       // pass the texCoord to the fragment shader\n       // The GPU will interpolate this value between points.\n       v_texCoord = a_texCoord;\n    }`,\n    fragment: `precision mediump float;\n\n    // our texture\n    uniform sampler2D u_image;\n    uniform vec2 iResolution;\n    // the texCoords passed in from the vertex shader.\n    varying vec2 v_texCoord;\n    \n    void main() {\n        vec2 uv = gl_FragCoord.xy / iResolution * 20.0;\n    \n        // get pixel information from uv location\n        vec4 texColor = texture2D(u_image, v_texCoord).bgra;\n    \n        float grayScale = (texColor.r + texColor.g + texColor.b) / 3.0;\n        gl_FragColor = vec4(grayScale,grayScale,grayScale, 1.0);\n    \n       \n    }`\n    }","import { paint } from \"./lib/shaderBinder\";\nimport {FlatGrayConvert} from  \"./shaders/flat-gray\";\nimport { GrayScaleConverter } from \"./shaders/graScale\";\n\nconst FlatGray = (fileName, canvas) => {\n    paint(fileName, canvas, FlatGrayConvert)\n}\n\nconst GrayScale = (fileName, canvas) => {\n    paint(fileName, canvas, GrayScaleConverter)\n}\n\nexport default paint;\nexport {\n    FlatGray,\n    GrayScale\n}"],"names":["root","factory","exports","module","define","amd","this","w","topWindow","error","msg","console","log","loadShader","gl","shaderSource","shaderType","opt_errorCallback","errFn","shader","createShader","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","split","map","l","i","concat","join","deleteShader","createProgram","shaders","opt_attribs","opt_locations","program","forEach","attachShader","attrib","ndx","bindAttribLocation","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","top","defaultShaderType","getBindPointForSamplerType","type","SAMPLER_2D","TEXTURE_2D","SAMPLER_CUBE","TEXTURE_CUBE_MAP","createUniformSetters","textureUnit","createUniformSetter","uniformInfo","bindPoint","unit","location","getUniformLocation","name","isArray","size","substr","FLOAT","v","uniform1fv","uniform1f","FLOAT_VEC2","uniform2fv","FLOAT_VEC3","uniform3fv","FLOAT_VEC4","uniform4fv","INT","uniform1iv","uniform1i","INT_VEC2","uniform2iv","INT_VEC3","uniform3iv","INT_VEC4","uniform4iv","BOOL","BOOL_VEC2","BOOL_VEC3","BOOL_VEC4","FLOAT_MAT2","uniformMatrix2fv","FLOAT_MAT3","uniformMatrix3fv","FLOAT_MAT4","uniformMatrix4fv","units","ii","info","push","textures","texture","index","activeTexture","TEXTURE0","bindTexture","toString","uniformSetters","numUniforms","ACTIVE_UNIFORMS","getActiveUniform","length","setter","setUniforms","setters","_len","arguments","values","Array","_key","_loop","uniforms","_values","_i","Object","keys","createAttributeSetters","attribSetters","createAttribSetter","b","value","disableVertexAttribArray","vertexAttrib4fv","vertexAttrib3fv","vertexAttrib2fv","vertexAttrib1fv","Error","bindBuffer","ARRAY_BUFFER","buffer","enableVertexAttribArray","vertexAttribPointer","numComponents","normalize","stride","offset","numAttribs","ACTIVE_ATTRIBUTES","attribInfo","getActiveAttrib","getAttribLocation","setAttributes","attribs","createVAOAndSetAttributes","indices","vao","createVertexArray","bindVertexArray","ELEMENT_ARRAY_BUFFER","setBuffersAndAttributes","buffers","browserPrefixes","createAugmentedTypedArray","numElements","opt_type","typedArray","cursor","ArrayBuffer","jj","reset","opt_index","defineProperty","get","augmentTypedArray","Float32Array","createBufferFromTypedArray","array","drawType","createBuffer","bufferData","STATIC_DRAW","allButIndices","getGLTypeForTypedArray","Int8Array","BYTE","Uint8Array","UNSIGNED_BYTE","Int16Array","SHORT","Uint16Array","UNSIGNED_SHORT","Int32Array","Uint32Array","UNSIGNED_INT","isArrayBuffer","a","guessNumComponentsFromName","indexOf","makeTypedArray","data","createAttribsFromArrays","arrays","opt_mapping","mapping","obj","filter","key","createMapping","attribName","bufferName","origArray","getArray","texcoordRE","colorRE","test","origFn","positionKeys","getNumElementsFromNonIndexedArrays","_step","_iterator","_createForOfIteratorHelper","s","n","done","k","err","e","f","arrayName","getNumComponents","drawBufferInfo","bufferInfo","primitiveType","count","undefined","TRIANGLES","drawElements","drawArrays","document","documentMode","window","StyleMedia","HTMLCanvasElement","prototype","getContext","args","slice","call","apply","createBuffersFromArrays","position","createBufferInfoFromArrays","createProgramFromScripts","vertexShaderSource","fragmentShaderSource","vertexShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","createProgramFromSources","shaderSources","createProgramInfo","source","script","getElementById","text","webglUtils","createVAOFromBufferInfo","programInfo","drawObjectList","objectsToDraw","lastUsedProgramInfo","lastUsedBufferInfo","object","bindBuffers","useProgram","glEnumToString","results","getExtensionWithKnownPrefixes","prefixedName","ext","getExtension","resizeCanvasToDisplaySize","canvas","multiplier","width","clientWidth","height","clientHeight","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","d","definition","o","enumerable","prop","hasOwnProperty","r","Symbol","toStringTag","require","paint","fileName","shaderCode","image","Image","Number","isNaN","src","onload","canvasEle","vertex","fragment","positionLocation","texcoordLocation","positionBuffer","x","y","x2","y2","setRectangle","texcoordBuffer","createTexture","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","texImage2D","RGBA","resolutionLocation","viewport","clearColor","clear","COLOR_BUFFER_BIT","uniform2f","render","FlatGrayConvert","GrayScaleConverter","FlatGray","GrayScale"],"sourceRoot":""}